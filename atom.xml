<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Turbine&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://turbin.github.io/"/>
  <updated>2017-08-21T15:57:02.750Z</updated>
  <id>https://turbin.github.io/</id>
  
  <author>
    <name>Turbine Yan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于一个链接的BUG</title>
    <link href="https://turbin.github.io/2017/08/21/about_the_linkage_error/"/>
    <id>https://turbin.github.io/2017/08/21/about_the_linkage_error/</id>
    <published>2017-08-21T15:43:00.000Z</published>
    <updated>2017-08-21T15:57:02.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于链接问题导致的程序BUG"><a href="#关于链接问题导致的程序BUG" class="headerlink" title="关于链接问题导致的程序BUG"></a>关于链接问题导致的程序BUG</h1><h2 id="疑难问题现象"><a href="#疑难问题现象" class="headerlink" title="疑难问题现象:"></a>疑难问题现象:</h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>一个安卓程序需要调用一个so库实现加解密操作，但是在更新了新版本后一直发现程序崩溃。</p>
<p>kernel pain:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">2017-08-21 10:43:58.724 F/libc    ( 4844): Fatal signal 11 (SIGSEGV), code 1, fault addr 0xf4c3eb4 in tid 4844 (test.app)</div><div class="line">2017-08-21 10:43:58.827 I/DEBUG   (  266): *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***</div><div class="line">2017-08-21 10:43:58.827 I/DEBUG   (  266): Build fingerprint: &apos;qcom/msm8909/msm8909:5.1.1/NewLand_N900/newland.20170815.163947:user/test-keys&apos;</div><div class="line">2017-08-21 10:43:58.827 I/DEBUG   (  266): Revision: &apos;0&apos;</div><div class="line">2017-08-21 10:43:58.827 I/DEBUG   (  266): ABI: &apos;arm&apos;</div><div class="line">2017-08-21 10:43:58.827 I/DEBUG   (  266): pid: 4844, tid: 4844, name: test.app  &gt;&gt;&gt; ./test.app &lt;&lt;&lt;</div><div class="line">2017-08-21 10:43:58.827 I/DEBUG   (  266): signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0xf4c3eb4</div><div class="line">2017-08-21 10:43:58.830 W/NativeCrashListener(  760): Couldn&apos;t find ProcessRecord for pid 4844</div><div class="line">2017-08-21 10:43:58.835 I/DEBUG   (  266):     r0 00000000  r1 becddf70  r2 becddf90  r3 0f4c3eb5</div><div class="line">2017-08-21 10:43:58.835 E/DEBUG   (  266): AM write failure (32 / Broken pipe)</div><div class="line">2017-08-21 10:43:58.835 I/DEBUG   (  266):     r4 b6f1efc8  r5 becde97c  r6 00000001  r7 b6f1cc34</div><div class="line">2017-08-21 10:43:58.835 I/DEBUG   (  266):     r8 00000000  r9 00000000  sl 00000000  fp becde81c</div><div class="line">2017-08-21 10:43:58.835 I/DEBUG   (  266):     ip 80000000  sp becddf50  lr b6f1d2b4  pc 0f4c3eb4  cpsr a00f0030</div><div class="line">2017-08-21 10:43:58.836 I/DEBUG   (  266): </div><div class="line">2017-08-21 10:43:58.836 I/DEBUG   (  266): backtrace:</div><div class="line">2017-08-21 10:43:58.836 I/DEBUG   (  266):     #00 pc 0f4c3eb4  &lt;unknown&gt;</div><div class="line">2017-08-21 10:43:58.836 I/DEBUG   (  266):     #01 pc 000012b0  /data/test.app (mfg_request_auth+1196)</div><div class="line">2017-08-21 10:43:58.836 I/DEBUG   (  266):     #02 pc 00000ca8  /data/test.app (main+116)</div><div class="line">2017-08-21 10:43:58.836 I/DEBUG   (  266):     #03 pc 0000f3f9  /system/lib/libc.so (__libc_init+44)</div><div class="line">2017-08-21 10:43:58.836 I/DEBUG   (  266):     #04 pc 00000bfc  /data/test.app (_start+88)</div><div class="line">2017-08-21 10:43:58.994 I/DEBUG   (  266): </div><div class="line">2017-08-21 10:43:58.994 I/DEBUG   (  266): Tombstone written to: /data/tombstones/tombstone_09</div><div class="line">2017-08-21 10:43:58.994 I/BootReceiver(  760): Copying /data/tombstones/tombstone_09 to DropBox (SYSTEM_TOMBSTONE)</div></pre></td></tr></table></figure>
<p>从日志上看到PC指针指向一个地址0xf4c3eb4,在kernel pain上可以看出这个地址是一个无效地址。</p>
<p>这点我们可以从后面的程序的map里面可以看出来。</p>
<p>观察brackstrace:中打印的调用栈的信息，在奔溃之前进入了一个叫做 <em>mgf_request_auth</em> 的函数中，调用位置在offet=1196的位置上。</p>
<p>此时，我们反汇编这个函数所在的bin文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">00000e04 &lt;mfg_request_auth&gt;:</div><div class="line">     e04:	e92d4810 	push	&#123;r4, fp, lr&#125;</div><div class="line">     e08:	e28db008 	add	fp, sp, #8</div><div class="line">     e0c:	e24ddd23 	sub	sp, sp, #2240	; 0x8c0</div><div class="line">     e10:	e24dd004 	sub	sp, sp, #4</div><div class="line">     e14:	e1a03000 	mov	r3, r0</div><div class="line">	 @ ---- 此处省略若干行 ----</div></pre></td></tr></table></figure>
<p>从这里我们可以看到函数的入口地址为:0x0E04，定位崩溃点位置为:</p>
<p><strong><em> 0x0E04 + 1196(这个是十进制数) </em></strong> 得到偏移位置为,0x12B0。<br>定位汇编文件中offset=12b0的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@ ----- 此处省略若干行　------</div><div class="line">   128c:	ebfffe29 	bl	b38 &lt;memset@plt&gt;</div><div class="line">   1290:	e59f32fc 	ldr	r3, [pc, #764]	; 1594 &lt;mfg_request_auth+0x790&gt;</div><div class="line">   1294:	e7943003 	ldr	r3, [r4, r3]</div><div class="line">   1298:	e5933000 	ldr	r3, [r3]</div><div class="line">   129c:	e24b1e8a 	sub	r1, fp, #2208	; 0x8a0</div><div class="line">   12a0:	e241100c 	sub	r1, r1, #12</div><div class="line">   12a4:	e24b2d22 	sub	r2, fp, #2176	; 0x880</div><div class="line">   12a8:	e242200c 	sub	r2, r2, #12</div><div class="line">   12ac:	e3a00000 	mov	r0, #0</div><div class="line">   12b0:	e12fff33 	blx	r3</div><div class="line">   12b4:	e3a03f63 	mov	r3, #396	; 0x18c</div><div class="line">   12b8:	e2833002 	add	r3, r3, #2</div><div class="line">   12bc:	e58d3000 	str	r3, [sp]</div><div class="line">   12c0:	e3a00003 	mov	r0, #3</div><div class="line">@ ----- 此处省略若干行　------</div></pre></td></tr></table></figure>
<p>请注意这里:</p>
<pre><code>12b0:    e12fff33     blx    r3 
</code></pre><p>这是一条跳转指令，跳转地址存放在r3寄存器中。所以我们可以查看在kernel pain 中打印的r3寄存器的值，r3＝0f4c3eb5。</p>
<p>BLX 本身是一条跳转并切换指令集的指令，跳转地址为0xf4c3eb5，但是这个地址是一个无效地址。</p>
<p>(奔溃的时PC=0xf4c3eb4, r3=0x0f4c3eb5,但是为什么PC指针是跳转地址的上一个字节地址，可能和ARM32指令集切换到Thumb16指令集的地址对齐规则有关，后续查阅资料后将补充该内容。)</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>从上述描述的现象看是崩溃的原因是由于跳转到错误的地址导致的。　</p>
<ul>
<li>那么这个错误的地址是如何引入的？</li>
<li>具体的奔溃位置在源码中的哪个部分呢？<br>于是我们开始结合汇编代码查阅源码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">int mfg_request_auth(uint8_t auth_code, uint8_t *obuf, uint32_t *olen)&#123;</div><div class="line">	// ... ... 此处省略Ｎ行　</div><div class="line">	TRACE(&quot;czl--------------------&quot;);</div><div class="line"></div><div class="line">	unsigned int nLen = 0;</div><div class="line">	char szPosType[123]=&#123;0&#125;;</div><div class="line"></div><div class="line">	NDK_SysGetPosInfo(SYS_HWINFO_GET_POS_TYPE, &amp;nLen, &amp;szPosType[0]);</div><div class="line">	// ..... 此处省略N行</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>发现崩溃位置就是调用了这个函数(NDK_SysGetPosInfo)的地方。</p>
<p>(具体结合汇编定位源码位置的方法有很多种，靠谱的方式就是通过GDB单步调试的方式。限于一些商业上的问题所以不方便公布所有源码内容，只能摘取部分关键片段)</p>
<p>初步以为是因为函数传参时候由于传递的参数不正确导致进出栈时出错而崩溃。后来我们全部按照参数表的规定进行了调整，并单独定义局部变量等方式进行了多种尝试后发现依然崩溃。</p>
<p>奔溃点还是在相同的地方。百思不得其解。</p>
<p>后来在浏览汇编源码时发现有个奇怪的现象:</p>
<p>奔溃的位置是一个地址跳转指令，但是我们调用的这个函数是被定义在一个函数库中，通过隐式调用方式进行调用的。</p>
<p>那么所有隐式调用过程在汇编展开时都会是这样的:</p>
<pre><code>128c:    ebfffe29     bl    b38 &lt;memset@plt&gt;
</code></pre><p>每个函数名的后面都有个@plt，这个是用来标识这个函数是定义在外部库中，通过BL 指令进行带链接方式的跳转。</p>
<p>它会产生一次长调用过程切换到GOT中查找函数名的对应入口地址。</p>
<p>如果发现该函数不存在有效的已链接地址，则引发加载器搜索对应的库文件将函数实现的汇编代码导出并生产一个有效地址，链接到可执行文件的GOT表中。</p>
<p>关于GOT和PLT可参考 <a href="http://blog.sina.com.cn/s/blog_54f82cc201011oqy.html" title="GOT(全局偏移表)和PLT(过程链接表)" target="_blank" rel="external">[GOT(全局偏移表)和PLT(过程链接表)]</a></p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>通过上述问题的分析我们可以大致分析出问题的原因，肯定是由于错误的链接方式导致的。<br>于是我查询了该函数所在的头文件，查看函数的声明方式:</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extern int (*NDK_SysGetPosInfo)(EM_SYS_HWINFO emFlag,uint *punLen,char *psBuf);</div></pre></td></tr></table></figure>
</code></pre><p>看到这里，真相大白。</p>
<p>我们看到这个函数在头文件中被声明为一个函数指针。但是我们在代码中一直都没有看到这个指针的赋值过程，所以编译器在初始化过程中任意赋值，就导致了一个错误地址被引入到代码中的。</p>
<p>这也是一个将显示调用和隐式调用混合调用的BUG。</p>
<p>所以,在C语言中，我们应该鼓励在调用函数指针时都使用指针解引用方式进行调用:</p>
<pre><code>int ret = (*NDK_SysGetPosInfo)(/* 这里省略若干参数*/);
</code></pre><p>这样我们就在调用时很清楚地知道现在我们是通过显式调用方式进行函数调用，在查看问题时，我们就能够更容易且直接地发现问题的原因。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于链接问题导致的程序BUG&quot;&gt;&lt;a href=&quot;#关于链接问题导致的程序BUG&quot; class=&quot;headerlink&quot; title=&quot;关于链接问题导致的程序BUG&quot;&gt;&lt;/a&gt;关于链接问题导致的程序BUG&lt;/h1&gt;&lt;h2 id=&quot;疑难问题现象&quot;&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="notes" scheme="https://turbin.github.io/categories/notes/"/>
    
    
      <category term="notes" scheme="https://turbin.github.io/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>链接方式的区别</title>
    <link href="https://turbin.github.io/2017/08/21/the%20_different_linkage/"/>
    <id>https://turbin.github.io/2017/08/21/the _different_linkage/</id>
    <published>2017-08-21T15:43:00.000Z</published>
    <updated>2017-08-21T15:49:18.435Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于链接方式的区别"><a href="#关于链接方式的区别" class="headerlink" title="关于链接方式的区别"></a>关于链接方式的区别</h1><h3 id="显示链接方式"><a href="#显示链接方式" class="headerlink" title="显示链接方式"></a>显示链接方式</h3><p>在程序中直接通过动态库装载的方式，对程序中定义的 <a href="https://www.baidu.com/link?url=IyNpctAiIjf-6aNwijWx3FSkI6B2g0hJwkhpa_TrYz-5agg8CTGLCvhXxTIsjb_hN5excOFQ1tFQZTHXKDfKEdQhW05M_wdn7wjUtyS_zR9RRKXZ0dM-bzUjnp0zWBLG&amp;wd=&amp;eqid=810661050000d2e400000006599a5210" title="函数指针" target="_blank" rel="external">[函数指针]</a>进行加载和赋值。</p>
<p>下面是用例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">//定义函数指针　以及变量</div><div class="line">void  *functionLib;   /*  Handle to shared lib file   */</div><div class="line">char *dlError;        /*  Pointer to error string     */</div><div class="line"></div><div class="line"></div><div class="line">//mag</div><div class="line">int (*NDK_MagOpen)(void);</div><div class="line">int (*NDK_MagClose)(void);</div><div class="line">int (*NDK_MagSwiped)(uchar * psSwiped);</div><div class="line">int (*NDK_MagReadNormal)(char *pszTk1, char *pszTk2, char　*pszTk3, int *pnErrorCode);</div><div class="line"></div><div class="line">// ... 省略N行　...</div><div class="line"></div><div class="line">// onload.c</div><div class="line">// 定义了一个加载宏</div><div class="line">#define DLSYM(lib, foo) &#123;	\</div><div class="line">	dlError = (char *)dlerror();	\</div><div class="line">	foo = dlsym( lib , #foo);	\</div><div class="line">	if( dlError || NULL == foo )&#123;	\</div><div class="line">		foo = NULL;	\</div><div class="line">		nRet -= 1;	\</div><div class="line">		LOGI(&quot;dlsym &quot;#foo&quot; fail:%s,Addr:%x,nRet:%d.&quot;, </div><div class="line">            dlError, (int)foo, nRet);	\</div><div class="line">		&#125;	\</div><div class="line">	else&#123;	\</div><div class="line">		LOGI(&quot;dlsym &quot;#foo&quot; succ. Addr:%x.&quot;, (int)foo);	\</div><div class="line">		&#125;	\</div><div class="line">	&#125;;	\</div><div class="line"></div><div class="line">//------- 通过显示加载方式加载库文件 --------------------</div><div class="line">	int   nRet = 0;             /*  return codes            */</div><div class="line"></div><div class="line">	// libnl_ndk.so</div><div class="line"></div><div class="line">	// libnlposapi.so</div><div class="line">	functionLib = dlopen(&quot;/system/lib/libabcd.so&quot;,RTLD_LAZY);</div><div class="line">	dlError = (char *)dlerror();</div><div class="line">	LOGI(&quot;dlopen libnlposapi.so error:%s&quot;, dlError);</div><div class="line">	if( functionLib == NULL )</div><div class="line">	&#123;</div><div class="line">		return (-1000);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//mag</div><div class="line">	DLSYM(functionLib, NDK_MagOpen);</div><div class="line">	DLSYM(functionLib, NDK_MagClose);</div><div class="line">	DLSYM(functionLib, NDK_MagSwiped);</div><div class="line">	DLSYM(functionLib, NDK_MagReadNormal);</div><div class="line">    // ... 省略N行　...</div></pre></td></tr></table></figure>
<p>这时候　在mk文件中可以不需要链接这个库(libabcd.so)就可以调用这个库里面的函数。</p>
<p>像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int ret= NDK_MagOpen();</div></pre></td></tr></table></figure>
<p>这时NDK头文件中也将函数声明定义为函数指针的方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int (*NDK_MagOpen)();</div></pre></td></tr></table></figure></p>
<h3 id="什么是隐式调用"><a href="#什么是隐式调用" class="headerlink" title="什么是隐式调用"></a>什么是隐式调用</h3><p>隐式调用，即通过在mk文件中显示指定需要调用链接的函数库的名称，然后在程序运行的过程中由os系统中的装载器以及链接器来完成函数的装载和链接过程。</p>
<p>如果一个函数定义在libabcd.so中时，我们需要调用它，就要在Android.mk文件中显示指定调用链接函数库名称:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LOCAL_LDLIBS += labcd</div></pre></td></tr></table></figure></p>
<p>然后在NDK头文件中声明为函数调用方式(注意区别前面的函数指针的什么方式):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int NDK_MagOpen();</div></pre></td></tr></table></figure></p>
<p>然后调用方式同函数指针的方式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int ret= NDK_MagOpen();</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于链接方式的区别&quot;&gt;&lt;a href=&quot;#关于链接方式的区别&quot; class=&quot;headerlink&quot; title=&quot;关于链接方式的区别&quot;&gt;&lt;/a&gt;关于链接方式的区别&lt;/h1&gt;&lt;h3 id=&quot;显示链接方式&quot;&gt;&lt;a href=&quot;#显示链接方式&quot; class=&quot;head
    
    </summary>
    
      <category term="notes" scheme="https://turbin.github.io/categories/notes/"/>
    
    
      <category term="notes" scheme="https://turbin.github.io/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://turbin.github.io/2017/08/13/debug_native_android_program_with_gdb/"/>
    <id>https://turbin.github.io/2017/08/13/debug_native_android_program_with_gdb/</id>
    <published>2017-08-13T07:48:05.367Z</published>
    <updated>2017-08-13T07:48:05.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用GBD-调试你的C-C-程序"><a href="#使用GBD-调试你的C-C-程序" class="headerlink" title="使用GBD 调试你的Ｃ/C++程序"></a>使用GBD 调试你的Ｃ/C++程序</h2><ol>
<li>首先使用如下的命令来编译你的工程：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ndk-build NDK_DEBUG=1 -C &lt;the path of your source code&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>其中，编译参数 <em>NDK_DEBUG=1</em> 指示编译链工具以DEBUG模式进行编译;<br>参数　<em>-C</em> 用于NDK编译链工具指定你的源码工程路径，主要是指定你的Android.mk文件路径;<br>等待编译完成后，在输出的路径下(libs/<your arch="">)就会产生几个新的文件。其中包含你的makefile的生成的目标文件，以及gdb.setup,和gdbserver。<br>路径目录如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">./lib/&lt;your arch&gt;/</div><div class="line">  |- gdb.setup -　the configuration file of GDB</div><div class="line">  |- gdbserver -　the execution file for running on device</div><div class="line">  |- others (your target files, like so file and execution  file etc.)</div></pre></td></tr></table></figure></your></p>
<ol>
<li><p>将你的gdbserver，以及编译生成的文件通过adb传到你的设备上的指定目录中，并记得将gdbserver设置为可执行属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">adb push &lt;your target files&gt; &lt;path on your device&gt;</div><div class="line">adb push gdbserver &lt;path on your device&gt;</div><div class="line">adb shell chmod 777  &lt;path on your device&gt;/gdbserver # set this file as execution</div></pre></td></tr></table></figure>
</li>
<li><p>在你的设备上运行gdbserver 并且需要制定gdbserver监听的端口.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb shell  &lt;path on your device&gt;/gdbserver &lt;host:port&gt; &lt;your debugging program&gt;</div></pre></td></tr></table></figure>
<p><em><host:port></host:port></em> 这个参数用来制定gdbserver作为服务端监听的主机ip以及端口，这样就可以支持远程GDB调试。<br>如果希望通过ADB进行访问，则可以将 <em>host</em>　指定为 <em>localhost</em>，然后选择任意的端口作为监听端口，下面的例子就是将　<em>12345</em> 作为监听端口使用。<br>当你成功运行gdbserver的时候，就会在你的adb shell控制台上看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Process ./main0 created; pid = 8163</div><div class="line">Listen on port 12345</div></pre></td></tr></table></figure>
</li>
<li><p>重定向你的ADB。如果你启动ADB的时候没有指定ADB的监听端口，就需要将ADB端口重定向到与你在gdbserver中所设置的相同的端口号上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">adb forward tcp:12345 tcp:12345</div></pre></td></tr></table></figure>
</li>
</ol>
<p>此时adb服务将监听12345端口，并将端口上的内容转发到PC上这样就架设完成了device到PC之间的桥梁。</p>
<ol>
<li>接着在PC端启动你的gdb。<br>这里要注意的是，PC端的gdb程序与device上的gdbserver在要使用相同gcc版本编译出来的。<br>在NDK中已经为我们准备好了相应的版本。如果你不确定使用哪个版本，记得在编译你的native文件时，使用参数　<em>-d</em> ：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ndk-build -d -C &lt;the path of your source code&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>你就可以看到在编译你的工程时，所使用的gcc版本以及路径信息。在这个gcc工具同级目录下，你就可以找到对应gdb可执行文件。<br>直接执行它,将进入gdb的命令状态，并提示等待用户输入命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb):</div></pre></td></tr></table></figure></p>
<p>在看到上述的命令行等待状态时，请输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb) target remote localhost:12345</div></pre></td></tr></table></figure></p>
<p>然后等待gdb连接gdbserver即可。<br>如果在调试你的程序过程中，发现gdb上显示为:　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0xb77706840 in ???()</div></pre></td></tr></table></figure></p>
<p>这表示你未导入你的程序的符号表，请在gdb命令状态下输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb) set solib-search-path &lt;path of gdb.setup&gt;</div></pre></td></tr></table></figure></p>
<p>还记得之前生成的那个 <em>gdb.setup</em>　文件吗，在这里将　<em><path of="" gdb.setup=""></path></em> 替换成该文件的路径即可。</p>
<h3 id="OK-ENJOY-YOUR-GDB"><a href="#OK-ENJOY-YOUR-GDB" class="headerlink" title="OK, ENJOY YOUR GDB!"></a>OK, ENJOY YOUR GDB!</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用GBD-调试你的C-C-程序&quot;&gt;&lt;a href=&quot;#使用GBD-调试你的C-C-程序&quot; class=&quot;headerlink&quot; title=&quot;使用GBD 调试你的Ｃ/C++程序&quot;&gt;&lt;/a&gt;使用GBD 调试你的Ｃ/C++程序&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;首先使用如下
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>My first powershell  code</title>
    <link href="https://turbin.github.io/2017/07/20/My_First_Powershell/"/>
    <id>https://turbin.github.io/2017/07/20/My_First_Powershell/</id>
    <published>2017-07-20T15:42:00.000Z</published>
    <updated>2017-07-20T15:59:17.859Z</updated>
    
    <content type="html"><![CDATA[<h2 id="因为懒，也因为烦。"><a href="#因为懒，也因为烦。" class="headerlink" title="因为懒，也因为烦。"></a>因为懒，也因为烦。</h2><p>所以为了发布版本简单可靠，也因为基于window环境下，所以学着写了powershell。<br>一边搜示例，一面学着写。大概有shell的基础入门挺快。<br>闲话少叙，直接提码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$targe=&quot;N900_4G&quot;</div><div class="line">$dest_dir=&quot;build_$targe&quot;</div><div class="line"></div><div class="line">Copy-Item -Path &quot;./Pad&quot;  -Destination $dest_dir -Recurse -Force</div><div class="line"></div><div class="line">$obj_dir=&apos;obj\local\armeabi&apos;</div><div class="line">$dirs=&apos;sdtp&apos;,&apos;api&apos;,&apos;mpos&apos;</div><div class="line">$clean=&apos;ndk-build clean -C&apos;</div><div class="line">$make=&apos;ndk-build -C&apos;</div><div class="line"></div><div class="line">foreach($build in $dirs)&#123;</div><div class="line">	ndk-build clean -C &quot;$dest_dir/$build/jni&quot;</div><div class="line">	ndk-build DEVICE=$targe -C &quot;$dest_dir/$build/jni&quot; &gt;&gt; &quot;./$targe.build&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我是要把工程目录Pad下面sdtp,api,mpos这三个库文件的目录依顺序进行编译，然后将编译的文件打包。<br>因为一共要发布3款终端产品，有三个不同产品编译选项开关。同时有两个大的分支版本。所以正式发布版本时，需要3<em>2</em>3=18次目录进出，然后进行ndk-build操作。并且很恶心的是，原来设定的库文件之间还有依赖关系，所以需要严格按照sdtp,api,mpos这三个目录的顺序进行编译。还有就是每个目录每次选择不同机型编译前都需要执行清空操作，因为不同的机型包含进来的代码可能还有些许差异。所以没有用脚本执行前，每次发版本都是异常辛苦，并且要很认真注意每个操作步骤的。<br>目前这个脚本，还不完善。接下来打算添加自动拷贝生成的目标文件功能，并且支持自动打包成指定命名规范的.zip包。那么，我只要把生成的文件附到邮件发布即可。<br>所以学点脚本，还是有用的，效率杠杠的。<br>这里推荐两个不错的powershell学习网址：</p>
<p><a href="http://www.pstips.net/cat/powershell/" target="_blank" rel="external">pstips</a> 这个是国内的一个不错的站点，中文。</p>
<p><a href="https://msdn.microsoft.com/zh-cn/powershell/reference/5.1/microsoft.powershell.management/microsoft.powershell.management" target="_blank" rel="external">Microsoft</a> 这是微软官方的站点，资料更详实。微软文档都做得不错。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;因为懒，也因为烦。&quot;&gt;&lt;a href=&quot;#因为懒，也因为烦。&quot; class=&quot;headerlink&quot; title=&quot;因为懒，也因为烦。&quot;&gt;&lt;/a&gt;因为懒，也因为烦。&lt;/h2&gt;&lt;p&gt;所以为了发布版本简单可靠，也因为基于window环境下，所以学着写了powershe
    
    </summary>
    
      <category term="coding" scheme="https://turbin.github.io/categories/coding/"/>
    
    
      <category term="power shell" scheme="https://turbin.github.io/tags/power-shell/"/>
    
  </entry>
  
  <entry>
    <title>After Rebuilding My Blog</title>
    <link href="https://turbin.github.io/2017/07/17/After%20Rebuilding%20My%20blog/"/>
    <id>https://turbin.github.io/2017/07/17/After Rebuilding My blog/</id>
    <published>2017-07-17T13:42:00.000Z</published>
    <updated>2017-07-17T13:49:30.710Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>终于</em></strong> 找回来原来博客的内容。很不容易，本来以为就这么丢了。<br>回头想来，还是要做好备份，不然自己辛辛苦苦积累的东西就这么容易地付之东流，着实可惜。<br>很久没有更新。只是因为懒癌犯了，不过因为前段时间自己的危机感，<br>促使自己要好好继续在码代码之余也要考虑下不断更新自己所思所想。<br>所以，后续会计划陆陆续续把原来的笔记整理出来，然后编写成博客文章填充这里，相对困乏的内容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;终于&lt;/em&gt;&lt;/strong&gt; 找回来原来博客的内容。很不容易，本来以为就这么丢了。&lt;br&gt;回头想来，还是要做好备份，不然自己辛辛苦苦积累的东西就这么容易地付之东流，着实可惜。&lt;br&gt;很久没有更新。只是因为懒癌犯了，不过因为前段时间自己的危机感，&lt;
    
    </summary>
    
      <category term="essay" scheme="https://turbin.github.io/categories/essay/"/>
    
    
      <category term="essay" scheme="https://turbin.github.io/tags/essay/"/>
    
  </entry>
  
  <entry>
    <title>为了改版</title>
    <link href="https://turbin.github.io/2017/02/05/%E6%94%B9%E7%89%88/"/>
    <id>https://turbin.github.io/2017/02/05/改版/</id>
    <published>2017-02-05T05:25:00.000Z</published>
    <updated>2017-07-17T13:42:52.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="改版"><a href="#改版" class="headerlink" title="改版"></a>改版</h1><ol>
<li>修改模板，添加文章分类</li>
<li>添加文档分类包含，随笔，编程，文档翻译，以及笔记</li>
</ol>
<p>====================== 时间分隔线 =========================================<br>发现在国内配置 <strong><em>Ruby</em></strong> 的运行环境，是一种那么痛苦的领悟。本身我也不会 <strong><em>Ruby</em></strong>,配置gem也是种痛苦，出现问题了也不知道该怎么解决。只能祭出短平快的方法，直接上 <strong><em>Hexo</em></strong>，原因就是，大家都在用嘛。</p>
<p><strong><em>Hexo</em></strong> 只要配置NodeJs环境就够了，相对来说比较简单。虽然很多人诟病它生成速度太慢。特别是博客文章多了以后。</p>
<p>多等等，应该也无所谓了……</p>
<p>好吧，先祝福自己的博客改版快乐～～～</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;改版&quot;&gt;&lt;a href=&quot;#改版&quot; class=&quot;headerlink&quot; title=&quot;改版&quot;&gt;&lt;/a&gt;改版&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;修改模板，添加文章分类&lt;/li&gt;
&lt;li&gt;添加文档分类包含，随笔，编程，文档翻译，以及笔记&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;====
    
    </summary>
    
      <category term="essay" scheme="https://turbin.github.io/categories/essay/"/>
    
    
      <category term="essay" scheme="https://turbin.github.io/tags/essay/"/>
    
  </entry>
  
  <entry>
    <title>QWebkit源码阅读笔记(1)</title>
    <link href="https://turbin.github.io/2017/02/05/QWebkit%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%E7%AC%94%E8%AE%B0(1)/"/>
    <id>https://turbin.github.io/2017/02/05/QWebkit源码走读笔记(1)/</id>
    <published>2017-02-05T03:45:45.000Z</published>
    <updated>2017-02-05T06:04:37.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文基于Qt5-5-1版本中的QWebkit"><a href="#本文基于Qt5-5-1版本中的QWebkit" class="headerlink" title="本文基于Qt5.5.1版本中的QWebkit"></a>本文基于Qt5.5.1版本中的QWebkit</h1><p>userAgent “Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/538.1 (KHTML, like Gecko) cordova Safari/538.1”</p>
<h1 id="页面加载的过程"><a href="#页面加载的过程" class="headerlink" title="页面加载的过程"></a>页面加载的过程</h1><h2 id="FrameLoader"><a href="#FrameLoader" class="headerlink" title="FrameLoader"></a>FrameLoader</h2><h3 id="FrameLoader-状态定义"><a href="#FrameLoader-状态定义" class="headerlink" title="FrameLoader-状态定义"></a>FrameLoader-状态定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">enum FrameState &#123;</div><div class="line">    FrameStateProvisional,</div><div class="line">    // This state indicates we are ready to commit to a page,</div><div class="line">    // which means the view will transition to use the new data source.</div><div class="line">    FrameStateCommittedPage,</div><div class="line">    FrameStateComplete</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="资源类型定义"><a href="#资源类型定义" class="headerlink" title="资源类型定义"></a>资源类型定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">enum Type &#123;</div><div class="line">    MainResource, // HTML</div><div class="line">    ImageResource, // 图片</div><div class="line">    CSSStyleSheet, // CSS文件</div><div class="line">    Script, // Javascript文件</div><div class="line">    FontResource, // 字体</div><div class="line">    RawResource // 其他包括多媒体文件等二进制文件</div><div class="line">#if ENABLE(SVG)</div><div class="line">    , SVGDocumentResource</div><div class="line">#endif</div><div class="line">#if ENABLE(XSLT)</div><div class="line">    , XSLStyleSheet</div><div class="line">#endif</div><div class="line">#if ENABLE(LINK_PREFETCH)</div><div class="line">    , LinkPrefetch</div><div class="line">    , LinkSubresource</div><div class="line">#endif</div><div class="line">#if ENABLE(VIDEO_TRACK)</div><div class="line">    , TextTrackResource</div><div class="line">#endif</div><div class="line">#if ENABLE(CSS_SHADERS)</div><div class="line">    , ShaderResource</div><div class="line">#endif</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在webkit中一般将HTML页面定义为主资源。</p>
<h3 id="FrameLoader-FrameState-FrameStateProvisional"><a href="#FrameLoader-FrameState-FrameStateProvisional" class="headerlink" title="FrameLoader::FrameState::FrameStateProvisional"></a>FrameLoader::FrameState::FrameStateProvisional</h3><p>Provisional 是Frame第一个定义状态,命名定义该状态是一个临时，且不确定状态<br>   TODO: 后续需要添加说明，该状态的命名原因；</p>
<h2 id="WebPage-gt-WebFrame-gt-FrameLoader的加载过程"><a href="#WebPage-gt-WebFrame-gt-FrameLoader的加载过程" class="headerlink" title="WebPage-&gt;WebFrame-&gt;FrameLoader的加载过程"></a>WebPage-&gt;WebFrame-&gt;FrameLoader的加载过程</h2><h4 id="Adapter层调用"><a href="#Adapter层调用" class="headerlink" title="Adapter层调用"></a>Adapter层调用</h4><ol>
<li><code>load -&gt; WebCore::Frame()-&gt;loader()</code>获得了 WebCore::FrameLoader</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">void QWebFrameAdapter::load(const QNetworkRequest&amp; req, QNetworkAccessManager::Operation operation, const QByteArray&amp; body)</div><div class="line">&#123;</div><div class="line">if (frame-&gt;tree()-&gt;parent())</div><div class="line">       pageAdapter-&gt;insideOpenCall = true;</div><div class="line"></div><div class="line">   QUrl url = ensureAbsoluteUrl(req.url());</div><div class="line"></div><div class="line">   WebCore::ResourceRequest request(url);</div><div class="line"></div><div class="line">   ... ...</div><div class="line"></div><div class="line">   frame-&gt;loader()-&gt;load(WebCore::FrameLoadRequest(frame, request));</div><div class="line"></div><div class="line">   if (frame-&gt;tree()-&gt;parent())</div><div class="line">       pageAdapter-&gt;insideOpenCall = false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>frame-&gt;loader()-&gt;load(WebCore::FrameLoadRequest(frame, request));</code><br>关键代码 <em>WebCore::FrameLoadRequest()</em> 调用的是 -&gt;  <code>FrameLoadRequest(Frame*, const ResourceRequest&amp;, const SubstituteData&amp; = SubstituteData())</code>;<br>这里WebCore::FrameLoadRequest().frameName() 返回的应该是空的string。</li>
<li><code>FrameLoadRequest(Frame*, const ResourceRequest&amp;, const SubstituteData&amp; = SubstituteData())</code>;<br>FrameLoader用空的SubstituteData去创建DocumentLoader，并使用DocumentLoader来完成MainResource的加载,SubstituteData用于在所请求的资源不可到达的时候，提供重定向指导。</li>
</ol>
<h4 id="通过FrameLoader-执行加载过程"><a href="#通过FrameLoader-执行加载过程" class="headerlink" title="通过FrameLoader 执行加载过程"></a>通过FrameLoader 执行加载过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">void FrameLoader::load(const FrameLoadRequest&amp; passedRequest)</div><div class="line">&#123;</div><div class="line">    FrameLoadRequest request(passedRequest);</div><div class="line"></div><div class="line">    if (m_inStopAllLoaders)</div><div class="line">        return;</div><div class="line"></div><div class="line">    if (!request.frameName().isEmpty()) &#123;</div><div class="line">        Frame* frame = findFrameForNavigation(request.frameName());</div><div class="line">        if (frame) &#123;</div><div class="line">            request.setShouldCheckNewWindowPolicy(false);</div><div class="line">            if (frame-&gt;loader() != this) &#123;</div><div class="line">                frame-&gt;loader()-&gt;load(request);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (request.shouldCheckNewWindowPolicy()) &#123;</div><div class="line">        policyChecker()-&gt;checkNewWindowPolicy(NavigationAction(request.resourceRequest(), NavigationTypeOther), FrameLoader::callContinueLoadAfterNewWindowPolicy, request.resourceRequest(), 0, request.frameName(), this);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!request.hasSubstituteData())</div><div class="line">        request.setSubstituteData(defaultSubstituteDataForURL(request.resourceRequest().url()));</div><div class="line"></div><div class="line">    RefPtr&lt;DocumentLoader&gt; loader = m_client-&gt;createDocumentLoader(request.resourceRequest(), request.substituteData());</div><div class="line">    if (request.lockHistory() &amp;&amp; m_documentLoader)</div><div class="line">        loader-&gt;setClientRedirectSourceForHistory(m_documentLoader-&gt;didCreateGlobalHistoryEntry() ? m_documentLoader-&gt;urlForHistory().string() : m_documentLoader-&gt;clientRedirectSourceForHistory());</div><div class="line">    load(loader.get());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>建立一个documentloader来加载资源：RefPtr<documentloader> loader = m_client-&gt;createDocumentLoader(request.resourceRequest(), request.substituteData());<br>注意这里的request.subtitueData是一个空对象。<br>然后调用：</documentloader></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">void FrameLoader::load(DocumentLoader* newDocumentLoader)</div><div class="line">&#123;</div><div class="line">    ……</div><div class="line">    if (m_documentLoader)</div><div class="line">        newDocumentLoader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());</div><div class="line"></div><div class="line">    // When we loading alternate content for an unreachable URL that we&apos;re</div><div class="line">    // visiting in the history list, we treat it as a reload so the history list</div><div class="line">    // is appropriately maintained.</div><div class="line">    //</div><div class="line">    // FIXME: This seems like a dangerous overloading of the meaning of &quot;FrameLoadTypeReload&quot; ...</div><div class="line">    // shouldn&apos;t a more explicit type of reload be defined, that means roughly</div><div class="line">    // &quot;load without affecting history&quot; ?</div><div class="line">    if (shouldReloadToHandleUnreachableURL(newDocumentLoader)) &#123;</div><div class="line">        // shouldReloadToHandleUnreachableURL() returns true only when the original load type is back-forward.</div><div class="line">        // In this case we should save the document state now. Otherwise the state can be lost because load type is</div><div class="line">        // changed and updateForBackForwardNavigation() will not be called when loading is committed.</div><div class="line">        history()-&gt;saveDocumentAndScrollState();</div><div class="line">        ASSERT(type == FrameLoadTypeStandard);</div><div class="line">        type = FrameLoadTypeReload;</div><div class="line">    &#125;</div><div class="line">    loadWithDocumentLoader(newDocumentLoader, type, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里的问题：<br>if (m_documentLoader)<br>        newDocumentLoader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 这里是m_documentLoader在FrameLoader中的定义：</div><div class="line">// Document loaders for the three phases of frame loading. Note that while</div><div class="line">// a new request is being loaded, the old document loader may still be referenced.</div><div class="line">// E.g. while a new request is in the &quot;policy&quot; state, the old document loader may</div><div class="line">// be consulted in particular as it makes sense to imply certain settings on the new loader.</div><div class="line">RefPtr&lt;DocumentLoader&gt; m_documentLoader;</div></pre></td></tr></table></figure>
<p><strong><em>在frame 加载的过程中的三个不同阶段，都将创建并调用到document loader这个类型。请注意一个新的请求正在被加载的时候，先前的document loader可能依然会被其他对象引用到。<br>比如，一个新的请求还处于”policy”这个状态时，新的loader依然会关联到先前的document loader中一些具体配置参数</em></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">void FrameLoader::loadWithDocumentLoader(DocumentLoader* loader, FrameLoadType type, PassRefPtr&lt;FormState&gt; prpFormState)</div><div class="line">&#123;</div><div class="line"></div><div class="line">    // Retain because dispatchBeforeLoadEvent may release the last reference to it.</div><div class="line">    RefPtr&lt;Frame&gt; protect(m_frame);</div><div class="line">    ASSERT(m_client-&gt;hasWebView()); // 所以页面在加载前会判断当前的client中是否包含了View的实现。</div><div class="line">    ……</div><div class="line"></div><div class="line">    if (shouldPerformFragmentNavigation(isFormSubmission, httpMethod, policyChecker()-&gt;loadType(), newURL)) &#123;</div><div class="line">        RefPtr&lt;DocumentLoader&gt; oldDocumentLoader = m_documentLoader;</div><div class="line">        NavigationAction action(loader-&gt;request(), policyChecker()-&gt;loadType(), isFormSubmission);</div><div class="line">        oldDocumentLoader-&gt;setTriggeringAction(action);</div><div class="line">        policyChecker()-&gt;stopCheck();</div><div class="line">        policyChecker()-&gt;checkNavigationPolicy(loader-&gt;request(), oldDocumentLoader.get(), formState,</div><div class="line">            callContinueFragmentScrollAfterNavigationPolicy, this);</div><div class="line">    &#125; else &#123;</div><div class="line">        if (Frame* parent = m_frame-&gt;tree()-&gt;parent())</div><div class="line">            loader-&gt;setOverrideEncoding(parent-&gt;loader()-&gt;documentLoader()-&gt;overrideEncoding());</div><div class="line">        policyChecker()-&gt;stopCheck();</div><div class="line">        // 将新创建的documentloader设置给m_policyDocumentLoader</div><div class="line">        setPolicyDocumentLoader(loader);</div><div class="line">        if (loader-&gt;triggeringAction().isEmpty())</div><div class="line">            // 将本次加载的请求记录在loader的m_triggeringAction中</div><div class="line">            loader-&gt;setTriggeringAction(NavigationAction(loader-&gt;request(), policyChecker()-&gt;loadType(), isFormSubmission));</div><div class="line">        if (Element* ownerElement = m_frame-&gt;ownerElement()) &#123;</div><div class="line">            // We skip dispatching the beforeload event if we&apos;ve already</div><div class="line">            // committed a real document load because the event would leak</div><div class="line">            // subsequent activity by the frame which the parent frame isn&apos;t</div><div class="line">            // supposed to learn. For example, if the child frame navigated to</div><div class="line">            // a new URL, the parent frame shouldn&apos;t learn the URL.</div><div class="line">            if (!m_stateMachine.committedFirstRealDocumentLoad()</div><div class="line">                &amp;&amp; !ownerElement-&gt;dispatchBeforeLoadEvent(loader-&gt;request().url().string())) &#123;</div><div class="line">                continueLoadAfterNavigationPolicy(loader-&gt;request(), formState, false);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 使用前面记录的loader.m_triggeringAction做校验，处理空白，重复，不可到达的请求，</div><div class="line">        // 该校验还要包括FrameLoaderClient实现的一些检查，以决定如何处理本次请求。</div><div class="line">        policyChecker()-&gt;checkNavigationPolicy(loader-&gt;request(), loader, formState,</div><div class="line">            callContinueLoadAfterNavigationPolicy, this);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>设置完成以后，通过<code>policyChecker()</code>校验请求后，调用<code>callContinueLoadAfterNavigationPolicy()</code>。<br>在<code>callContinueLoadAfterNavigationPolicy()</code> 中将设置FrameLoader的状态转换为</em>Provisional<em>。<a href="/FrameLoader-状态定义/">参考FrameLoader的状态定义</a></em></strong><br>这是一个简单 包裹方法，简单地做了一个转换。实际调用的是continueLoadAfterNavigationPolicy。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void FrameLoader::callContinueLoadAfterNavigationPolicy(void* argument,</div><div class="line">    const ResourceRequest&amp; request, PassRefPtr&lt;FormState&gt; formState, bool shouldContinue)</div><div class="line">&#123;</div><div class="line">    FrameLoader* loader = static_cast&lt;FrameLoader*&gt;(argument);</div><div class="line">    loader-&gt;continueLoadAfterNavigationPolicy(request, formState, shouldContinue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="关于-continueLoadAfterNavigationPolicy-说明"><a href="#关于-continueLoadAfterNavigationPolicy-说明" class="headerlink" title="关于 continueLoadAfterNavigationPolicy()说明"></a>关于 <code>continueLoadAfterNavigationPolicy()</code>说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">void FrameLoader::continueLoadAfterNavigationPolicy(const ResourceRequest&amp;, PassRefPtr&lt;FormState&gt; formState, bool shouldContinue)</div><div class="line">&#123;</div><div class="line">    // If we loaded an alternate page to replace an unreachableURL, we&apos;ll get in here with a</div><div class="line">    // nil policyDataSource because loading the alternate page will have passed</div><div class="line">    // through this method already, nested; otherwise, policyDataSource should still be set.</div><div class="line">    ASSERT(m_policyDocumentLoader || !m_provisionalDocumentLoader-&gt;unreachableURL().isEmpty());</div><div class="line"></div><div class="line">    bool isTargetItem = history()-&gt;provisionalItem() ? history()-&gt;provisionalItem()-&gt;isTargetItem() : false;</div><div class="line"></div><div class="line">    // Two reasons we can&apos;t continue:</div><div class="line">    //    1) Navigation policy delegate said we can&apos;t so request is nil. A primary case of this</div><div class="line">    //       is the user responding Cancel to the form repost nag sheet.</div><div class="line">    //    2) User responded Cancel to an alert popped up by the before unload event handler.</div><div class="line">    bool canContinue = shouldContinue &amp;&amp; shouldClose();</div><div class="line"></div><div class="line">    if (!canContinue) &#123;</div><div class="line">        // If we were waiting for a quick redirect, but the policy delegate decided to ignore it, then we</div><div class="line">        // need to report that the client redirect was cancelled.</div><div class="line">        if (m_quickRedirectComing)</div><div class="line">            clientRedirectCancelledOrFinished(false);</div><div class="line"></div><div class="line">        setPolicyDocumentLoader(0);</div><div class="line"></div><div class="line">        // If the navigation request came from the back/forward menu, and we punt on it, we have the</div><div class="line">        // problem that we have optimistically moved the b/f cursor already, so move it back.  For sanity,</div><div class="line">        // we only do this when punting a navigation for the target frame or top-level frame.  </div><div class="line">        if ((isTargetItem || isLoadingMainFrame()) &amp;&amp; isBackForwardLoadType(policyChecker()-&gt;loadType())) &#123;</div><div class="line">            if (Page* page = m_frame-&gt;page()) &#123;</div><div class="line">                Frame* mainFrame = page-&gt;mainFrame();</div><div class="line">                if (HistoryItem* resetItem = mainFrame-&gt;loader()-&gt;history()-&gt;currentItem()) &#123;</div><div class="line">                    page-&gt;backForward()-&gt;setCurrentItem(resetItem);</div><div class="line">                    m_frame-&gt;loader()-&gt;client()-&gt;updateGlobalHistoryItemForPage();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    FrameLoadType type = policyChecker()-&gt;loadType();</div><div class="line">    // A new navigation is in progress, so don&apos;t clear the history&apos;s provisional item.</div><div class="line">    stopAllLoaders(ShouldNotClearProvisionalItem);</div><div class="line"></div><div class="line">    // &lt;rdar://problem/6250856&gt; - In certain circumstances on pages with multiple frames, stopAllLoaders()</div><div class="line">    // might detach the current FrameLoader, in which case we should bail on this newly defunct load.</div><div class="line">    if (!m_frame-&gt;page())</div><div class="line">        return;</div><div class="line"></div><div class="line">#if ENABLE(JAVASCRIPT_DEBUGGER) &amp;&amp; ENABLE(INSPECTOR)</div><div class="line">    if (Page* page = m_frame-&gt;page()) &#123;</div><div class="line">        if (page-&gt;mainFrame() == m_frame)</div><div class="line">            m_frame-&gt;page()-&gt;inspectorController()-&gt;resume();</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">    setProvisionalDocumentLoader(m_policyDocumentLoader.get());</div><div class="line">    m_loadType = type;</div><div class="line">    setState(FrameStateProvisional);</div><div class="line"></div><div class="line">    setPolicyDocumentLoader(0);</div><div class="line"></div><div class="line">    if (isBackForwardLoadType(type) &amp;&amp; history()-&gt;provisionalItem()-&gt;isInPageCache()) &#123;</div><div class="line">        loadProvisionalItemFromCachedPage();</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    ///</div><div class="line">    if (formState)</div><div class="line">        m_client-&gt;dispatchWillSubmitForm(&amp;PolicyChecker::continueLoadAfterWillSubmitForm, formState);</div><div class="line">    else</div><div class="line">        continueLoadAfterWillSubmitForm();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  在继续执行加载的策略中判断，用户是否取消加载，如果取消加载则将已加载的内容替换成缓存中的历史记录<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">// Two reasons we can&apos;t continue:</div><div class="line">//    1) Navigation policy delegate said we can&apos;t so request is nil. A primary case of this</div><div class="line">//       is the user responding Cancel to the form repost nag sheet.</div><div class="line">//    2) User responded Cancel to an alert popped up by the before unload event handler.</div><div class="line">bool canContinue = shouldContinue &amp;&amp; shouldClose();</div><div class="line"></div><div class="line">if (!canContinue) &#123;</div><div class="line">    // If we were waiting for a quick redirect, but the policy delegate decided to ignore it, then we</div><div class="line">    // need to report that the client redirect was cancelled.</div><div class="line">    if (m_quickRedirectComing)</div><div class="line">        clientRedirectCancelledOrFinished(false);</div><div class="line"></div><div class="line">    setPolicyDocumentLoader(0);</div><div class="line"></div><div class="line">    // If the navigation request came from the back/forward menu, and we punt on it, we have the</div><div class="line">    // problem that we have optimistically moved the b/f cursor already, so move it back.  For sanity,</div><div class="line">    // we only do this when punting a navigation for the target frame or top-level frame.  </div><div class="line">    if ((isTargetItem || isLoadingMainFrame()) &amp;&amp; isBackForwardLoadType(policyChecker()-&gt;loadType())) &#123;</div><div class="line">        if (Page* page = m_frame-&gt;page()) &#123;</div><div class="line">            Frame* mainFrame = page-&gt;mainFrame();</div><div class="line">            if (HistoryItem* resetItem = mainFrame-&gt;loader()-&gt;history()-&gt;currentItem()) &#123;</div><div class="line">                page-&gt;backForward()-&gt;setCurrentItem(resetItem);</div><div class="line">                m_frame-&gt;loader()-&gt;client()-&gt;updateGlobalHistoryItemForPage();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  如果用户未取消加载操作，则根据表单状态，执行后续流程。一般都是走<code>else</code>这个分支。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (formState)</div><div class="line">   m_client-&gt;dispatchWillSubmitForm(&amp;PolicyChecker::continueLoadAfterWillSubmitForm, formState);</div><div class="line">else</div><div class="line">   continueLoadAfterWillSubmitForm();</div></pre></td></tr></table></figure></p>
<p>接着开始进入页面的真正加载流程。</p>
<h4 id="开始加载页面"><a href="#开始加载页面" class="headerlink" title="开始加载页面"></a>开始加载页面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">void FrameLoader::continueLoadAfterWillSubmitForm()</div><div class="line">&#123;</div><div class="line">    if (!m_provisionalDocumentLoader)</div><div class="line">        return;</div><div class="line"></div><div class="line">    prepareForLoadStart();</div><div class="line"></div><div class="line">    // The load might be cancelled inside of prepareForLoadStart(), nulling out the m_provisionalDocumentLoader,</div><div class="line">    // so we need to null check it again.</div><div class="line">    if (!m_provisionalDocumentLoader)</div><div class="line">        return;</div><div class="line"></div><div class="line">    DocumentLoader* activeDocLoader = activeDocumentLoader();</div><div class="line">    if (activeDocLoader &amp;&amp; activeDocLoader-&gt;isLoadingMainResource())</div><div class="line">        return;</div><div class="line"></div><div class="line">    m_loadingFromCachedPage = false;</div><div class="line">    m_provisionalDocumentLoader-&gt;startLoadingMainResource();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><p><code>prepareForLoadStart();</code> 通知进度条进行加载准备，向client 分发消息通知进行加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void FrameLoader::prepareForLoadStart()</div><div class="line">&#123;</div><div class="line">   m_progressTracker-&gt;progressStarted();</div><div class="line">   m_client-&gt;dispatchDidStartProvisionalLoad();</div><div class="line">   ... ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>m_provisionalDocumentLoader-&gt;startLoadingMainResource();</code> 开始将首页面作为主资源进行加载，<br>这里实际调用的是DocumentLoader::startLoadingMainResource;</p>
</li>
</ol>
<h3 id="DocumentLoader"><a href="#DocumentLoader" class="headerlink" title="DocumentLoader"></a>DocumentLoader</h3><p>所有资源的加载，都是通过DocumentLoader 以及子类实现的;<br>m_provisionalDocumentLoader 就是一个DocumentLoader;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">void DocumentLoader::startLoadingMainResource()</div><div class="line">&#123;</div><div class="line">    ... ...</div><div class="line"></div><div class="line">    ResourceRequest request(m_request);</div><div class="line">    DEFINE_STATIC_LOCAL(ResourceLoaderOptions, mainResourceLoadOptions,</div><div class="line">        (SendCallbacks, SniffContent, BufferData, AllowStoredCredentials, AskClientForAllCredentials, SkipSecurityCheck, UseDefaultOriginRestrictionsForType));</div><div class="line">    CachedResourceRequest cachedResourceRequest(request, mainResourceLoadOptions);</div><div class="line"></div><div class="line">    m_mainResource = m_cachedResourceLoader-&gt;requestMainResource(cachedResourceRequest);</div><div class="line">    if (!m_mainResource) &#123;</div><div class="line">        setRequest(ResourceRequest());</div><div class="line">        // If the load was aborted by clearing m_request, it&apos;s possible the ApplicationCacheHost</div><div class="line">        // is now in a state where starting an empty load will be inconsistent. Replace it with</div><div class="line">        // a new ApplicationCacheHost.</div><div class="line">        m_applicationCacheHost = adoptPtr(new ApplicationCacheHost(this));</div><div class="line">        maybeLoadEmpty();</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!mainResourceLoader()) &#123;</div><div class="line">        m_identifierForLoadWithoutResourceLoader = m_frame-&gt;page()-&gt;progress()-&gt;createUniqueIdentifier();</div><div class="line">        frameLoader()-&gt;notifier()-&gt;assignIdentifierToInitialRequest(m_identifierForLoadWithoutResourceLoader, this, request);</div><div class="line">        frameLoader()-&gt;notifier()-&gt;dispatchWillSendRequest(this, m_identifierForLoadWithoutResourceLoader, request, ResourceResponse());</div><div class="line">    &#125;</div><div class="line">    m_mainResource-&gt;addClient(this);</div><div class="line"></div><div class="line">    // A bunch of headers are set when the underlying ResourceLoader is created, and m_request needs to include those.</div><div class="line">    if (mainResourceLoader())</div><div class="line">        request = mainResourceLoader()-&gt;originalRequest();</div><div class="line">    // If there was a fragment identifier on m_request, the cache will have stripped it. m_request should include</div><div class="line">    // the fragment identifier, so add that back in.</div><div class="line">    if (equalIgnoringFragmentIdentifier(m_request.url(), request.url()))</div><div class="line">        request.setURL(m_request.url());</div><div class="line">    setRequest(request);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><strong><em><code>关于ResourceRequest request(m_request);</code></em></strong><br>这里仅仅是将指针值赋值给新的request 还是将整个m_request 的内容都拷贝给了request？<br>如果是整个内容都拷贝给了request,那么下面执行的语句：<figure class="highlight plain"><figcaption><span>If there was a fragment identifier on m_request, the cache will have stripped it. m_request should include</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// the fragment identifier, so add that back in.</div><div class="line">if (equalIgnoringFragmentIdentifier(m_request.url(), request.url()))</div><div class="line">    request.setURL(m_request.url());</div></pre></td></tr></table></figure>
</li>
</ol>
<p>不是太理解这边的执行内容。</p>
<ol>
<li><p>在这里通过创建mainResource,然后将自己注册给mainResource作为回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">line 1382:</div><div class="line">m_mainResource = m_cachedResourceLoader-&gt;requestMainResource(cachedResourceRequest);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">line 1398:</div><div class="line">m_mainResource-&gt;addClient(this);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>接着就将请求转向了<code>CachedResourceLoader</code>。</p>
<h3 id="CachedResourceLoader"><a href="#CachedResourceLoader" class="headerlink" title="CachedResourceLoader"></a>CachedResourceLoader</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 注释说明：</div><div class="line">// The CachedResourceLoader provides a per-context interface to the MemoryCache</div><div class="line">// and enforces a bunch of security checks and rules for resource revalidation.</div><div class="line">// Its lifetime is roughly per-DocumentLoader, in that it is generally created</div><div class="line">// in the DocumentLoader constructor and loses its ability to generate network</div><div class="line">// requests when the DocumentLoader is destroyed. Documents also hold a</div><div class="line">// RefPtr&lt;CachedResourceLoader&gt; for their lifetime (and will create one if they</div><div class="line">// are initialized without a Frame), so a Document can keep a CachedResourceLoader</div><div class="line">// alive past detach if scripts still reference the Document.</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CachedResourceHandle&lt;CachedRawResource&gt; CachedResourceLoader::requestMainResource(CachedResourceRequest&amp; request)</div><div class="line">&#123;</div><div class="line">    return static_cast&lt;CachedRawResource*&gt;(requestResource(CachedResource::MainResource, request).get());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过调用requestResource 来向服务端请求<a href="/资源类型定义/">主资源</a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">CachedResourceHandle&lt;CachedResource&gt; CachedResourceLoader::requestResource(CachedResource::Type type, CachedResourceRequest&amp; request)</div><div class="line">&#123;</div><div class="line">    // 判断是否由缓存中预取得到相应的资源对象</div><div class="line">    ... ...</div><div class="line"></div><div class="line">    const RevalidationPolicy policy = determineRevalidationPolicy(type, request.mutableResourceRequest(), request.forPreload(), resource.get(), request.defer());</div><div class="line">    switch (policy) &#123;</div><div class="line">    case Reload:</div><div class="line">        memoryCache()-&gt;remove(resource.get());</div><div class="line">        // Fall through</div><div class="line">    case Load:</div><div class="line">        resource = loadResource(type, request, request.charset());</div><div class="line">        break;</div><div class="line">    case Revalidate:</div><div class="line">        resource = revalidateResource(request, resource.get());</div><div class="line">        break;</div><div class="line">    case Use:</div><div class="line">        if (!shouldContinueAfterNotifyingLoadedFromMemoryCache(resource.get()))</div><div class="line">            return 0;</div><div class="line">        memoryCache()-&gt;resourceAccessed(resource.get());</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ... ...</div><div class="line"></div><div class="line">    if ((policy != Use || resource-&gt;stillNeedsLoad()) &amp;&amp; CachedResourceRequest::NoDefer == request.defer()) &#123;</div><div class="line">        resource-&gt;load(this, request.options());</div><div class="line"></div><div class="line">        // We don&apos;t support immediate loads, but we do support immediate failure.</div><div class="line">        if (resource-&gt;errorOccurred()) &#123;</div><div class="line">            if (resource-&gt;inCache())</div><div class="line">                memoryCache()-&gt;remove(resource.get());</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ... ...</div><div class="line">    return resource;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>const RevalidationPolicy policy = determineRevalidationPolicy(type, request.mutableResourceRequest(), request.forPreload(), resource.get(), request.defer());</code> 这里通过封装的加载策略，来判断加载方式。<br>加载的策略方式有 reLoad, Revalidate, Use, Load。<br>这里仅分析在Load的情况，其他情况待分解。<br><code>resource = loadResource(type, request, request.charset());</code> 该函数调用了<code>static CachedResource* createResource(CachedResource::Type type, ResourceRequest&amp; request, const String&amp; charset)</code><br>来创建指定的资源类型，并将其返回。<br>然后程序执行到这句：<br><code>if ((policy != Use || resource-&gt;stillNeedsLoad()) &amp;&amp; CachedResourceRequest::NoDefer == request.defer()) {
        resource-&gt;load(this, request.options());</code><br>新加载的资源对应策略为load,并且主资源未设置Defer,resource-&gt;stillNeedsLoad(),默认情况下都返回False。<br><strong><em>所以<code>policy != Use</code> 与 <code>CachedResourceRequest::NoDefer == request.defer()</code>同时命中，执行resource-&gt;load方法。</em></strong><br>执行<code>CachedResource::load(CachedResourceLoader* cachedResourceLoader, const ResourceLoaderOptions&amp; options)</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void CachedResource::load(CachedResourceLoader* cachedResourceLoader, const ResourceLoaderOptions&amp; options)</div><div class="line">&#123;</div><div class="line">    // 此处忽略若干行</div><div class="line">    ... ...</div><div class="line"></div><div class="line">    m_loader = platformStrategies()-&gt;loaderStrategy()-&gt;resourceLoadScheduler()-&gt;scheduleSubresourceLoad(cachedResourceLoader-&gt;frame(), this, request, request.priority(), options);</div><div class="line">    if (!m_loader) &#123;</div><div class="line">        failBeforeStarting();</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    m_status = Pending;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于webkit需要支持不同的平台，所以将不同平台下资源加载的方式使用策略模式进行了封装。然后将资源调用通过resourceLoadScheduler来统一请求和调度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">PassRefPtr&lt;SubresourceLoader&gt; ResourceLoadScheduler::scheduleSubresourceLoad(Frame* frame, CachedResource* resource, const ResourceRequest&amp; request, ResourceLoadPriority priority, const ResourceLoaderOptions&amp; options)</div><div class="line">&#123;</div><div class="line">    RefPtr&lt;SubresourceLoader&gt; loader = SubresourceLoader::create(frame, resource, request, options);</div><div class="line">    if (loader)</div><div class="line">        scheduleLoad(loader.get(), priority);</div><div class="line">    return loader.release();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里创建了一个资源调度器，进行加载调用。<br>从CachedResource::load -&gt; ResourceLoadScheduler::scheduleSubresourceLoad 这里的调用流程与其他派生资源(如图片、CSS文件、JS文件等)的加载是同一个流程。</p>
<h1 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h1><h3 id="Document-对象的三个状态具体转换过程"><a href="#Document-对象的三个状态具体转换过程" class="headerlink" title="Document 对象的三个状态具体转换过程"></a>Document 对象的三个状态具体转换过程</h3><p>在Javascript中页面的DOM加载经历三个状态， loading, interactive, complete。<br>三个状态定义在Document中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">// 三个状态通过readyState 接口返回</div><div class="line">String Document::readyState() const</div><div class="line">&#123;</div><div class="line">    DEFINE_STATIC_LOCAL(const String, loading, (ASCIILiteral(&quot;loading&quot;)));</div><div class="line">    DEFINE_STATIC_LOCAL(const String, interactive, (ASCIILiteral(&quot;interactive&quot;)));</div><div class="line">    DEFINE_STATIC_LOCAL(const String, complete, (ASCIILiteral(&quot;complete&quot;)));</div><div class="line">    switch (m_readyState) &#123;</div><div class="line">    case Loading:</div><div class="line">        return loading;</div><div class="line">    case Interactive:</div><div class="line">        return interactive;</div><div class="line">    case Complete:</div><div class="line">        return complete;</div><div class="line">    &#125;</div><div class="line">    ASSERT_NOT_REACHED();</div><div class="line">    return String();</div><div class="line">&#125;</div><div class="line">// 三个状态通过setReadyState接口进行更改</div><div class="line">void Document::setReadyState(ReadyState readyState)</div><div class="line">&#123;</div><div class="line">    if (readyState == m_readyState)</div><div class="line">        return;</div><div class="line">    switch (readyState) &#123;</div><div class="line">    case Loading:</div><div class="line">        if (!m_documentTiming.domLoading)</div><div class="line">            m_documentTiming.domLoading = monotonicallyIncreasingTime();</div><div class="line">        break;</div><div class="line">    case Interactive:</div><div class="line">        if (!m_documentTiming.domInteractive)</div><div class="line">            m_documentTiming.domInteractive = monotonicallyIncreasingTime();</div><div class="line">        break;</div><div class="line">    case Complete:</div><div class="line">        if (!m_documentTiming.domComplete)</div><div class="line">            m_documentTiming.domComplete = monotonicallyIncreasingTime();</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">    m_readyState = readyState;</div><div class="line">    /// COMMENT 通知页面上的监听者(JS)</div><div class="line">    dispatchEvent(Event::create(eventNames().readystatechangeEvent, false, false));</div><div class="line"></div><div class="line">    if (settings() &amp;&amp; settings()-&gt;suppressesIncrementalRendering())</div><div class="line">        setVisualUpdatesAllowed(readyState);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文基于Qt5-5-1版本中的QWebkit&quot;&gt;&lt;a href=&quot;#本文基于Qt5-5-1版本中的QWebkit&quot; class=&quot;headerlink&quot; title=&quot;本文基于Qt5.5.1版本中的QWebkit&quot;&gt;&lt;/a&gt;本文基于Qt5.5.1版本中的QWebk
    
    </summary>
    
      <category term="notes" scheme="https://turbin.github.io/categories/notes/"/>
    
    
      <category term="Webkit源码阅读" scheme="https://turbin.github.io/tags/Webkit%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>关于 no_new_privs 说明</title>
    <link href="https://turbin.github.io/2017/01/28/no_new_privs%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/"/>
    <id>https://turbin.github.io/2017/01/28/no_new_privs中文说明翻译/</id>
    <published>2017-01-28T12:30:45.000Z</published>
    <updated>2017-02-05T05:20:26.603Z</updated>
    
    <content type="html"><![CDATA[<p>The original article, please reference here <a href="http://tomoyo.osdn.jp/cgi-bin/lxr/source/Documentation/prctl/no_new_privs.txt" target="_blank" rel="external">no_new_privs.txt</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The execve system call can grant a newly-started program privileges that</div><div class="line">its parent did not have.</div></pre></td></tr></table></figure></p>
<p>execve 系统调用能够赋予最新启动的进程其父进程没有的权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">The most obvious examples are setuid/setgid</div><div class="line">programs and file capabilities.  To prevent the parent program from</div><div class="line">gaining these privileges as well, the kernel and user code must be</div><div class="line">careful to prevent the parent from doing anything that could subvert the</div><div class="line">child.</div></pre></td></tr></table></figure></p>
<p>最常见的例子就是通过 setuid和setgid来设置程序进程的uid以及gid以及文件的访问权限。(子进程)同样继承了父进程的权限，在内核以及用户代码中必须小心这些权限信息，避免造成子进程崩溃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">For example:</div><div class="line"></div><div class="line"> - The dynamic loader handles LD_* environment variables differently if</div><div class="line">   a program is setuid.</div><div class="line"></div><div class="line"> - chroot is disallowed to unprivileged processes, since it would allow</div><div class="line">   /etc/passwd to be replaced from the point of view of a process that</div><div class="line">   inherited chroot.</div><div class="line"></div><div class="line"> - The exec code has special handling for ptrace.</div></pre></td></tr></table></figure>
<p>例如：</p>
<ul>
<li><p>一个被重新设置了uid的程序，(启动运行时)动态链接器在处理这些以”LD_”为前缀的环境变量时，要注意(其文件路径的权限)差异；</p>
</li>
<li><p>使用chroot生成的进程，它所加载的/etc/passwd文件所指向的路径将会(不同的root运行环境所)变更。因此chroot会禁止那些(在新环境下)未定义权限的进程运行；</p>
</li>
<li><p>使用ptrace来跟踪指定的代码；</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">These are all ad-hoc fixes.  The no_new_privs bit (since Linux 3.5) is a</div><div class="line">new, generic mechanism to make it safe for a process to modify its</div><div class="line">execution environment in a manner that persists across execve.  Any task</div><div class="line">can set no_new_privs.  Once the bit is set, it is inherited across fork,</div><div class="line">clone, and execve and cannot be unset.  With no_new_privs set, execve</div><div class="line">promises not to grant the privilege to do anything that could not have</div><div class="line">been done without the execve call.  For example, the setuid and setgid</div><div class="line">bits will no longer change the uid or gid; file capabilities will not</div><div class="line">add to the permitted set, and LSMs will not relax constraints after</div><div class="line">execve.</div></pre></td></tr></table></figure>
<p>因此内核引入了一些临时性解决方案。到后来，内核(从 Linux3.5版本开始)引入(设置)”no_new_privs”位的全新的通用机制，提供给进程一种能够在execve()调用整个阶段都能持续有效且安全的方法。任何一个进程都可以设置”no_new_privs”位。然而一旦(当前进程)被置位，不论通过fork,clone,或者execve生成的子进程都无法将该位清零。因此通过”no_new_privs”置位的方式，execve函数可以确保所有的操作都必须调用execve()(判定)赋予权限后才被执行。比如，<br>  setuid和setgid操作将无法有效执行；<br>  文件访问权限无法被扩增，LINUX安全模块(LSM-Linux Security Module)在execve()执行后不会释放控制权限；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">To set no_new_privs, use prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0).</div></pre></td></tr></table></figure>
<p>设置”no_new_privs”位，可以这样调用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Be careful, though: LSMs might also not tighten constraints on exec</div><div class="line">in no_new_privs mode.  (This means that setting up a general-purpose</div><div class="line">service launcher to set no_new_privs before execing daemons may</div><div class="line">interfere with LSM-based sandboxing.)</div></pre></td></tr></table></figure>
<p>要注意到的是，因此：处于”no_new_privs”模式下,调用exec()函数时，Linux安全模块将收紧权限控制。<br>(这意味着建立一个通用启动器，在设置no_new_privs之前execing守护进程可能会受到LSM沙盒的影响)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Note that no_new_privs does not prevent privilege changes that do not</div><div class="line">involve execve.  An appropriately privileged task can still call</div><div class="line">setuid(2) and receive SCM_RIGHTS datagrams.</div></pre></td></tr></table></figure></p>
<p>注意，通过execve调用，可以确保处于”no_new_privs”模式(下的进程)权限不发生变化。一个适当的特权任务，可以持续完成uid设置，以及接收SCM_RIGHTS报文数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">There are two main use cases for no_new_privs so far:</div><div class="line"></div><div class="line"> - Filters installed for the seccomp mode 2 sandbox persist across</div><div class="line">   execve and can change the behavior of newly-executed programs.</div><div class="line">   Unprivileged users are therefore only allowed to install such filters</div><div class="line">   if no_new_privs is set.</div><div class="line"></div><div class="line"> - By itself, no_new_privs can be used to reduce the attack surface</div><div class="line">   available to an unprivileged user.  If everything running with a</div><div class="line">   given uid has no_new_privs set, then that uid will be unable to</div><div class="line">   escalate its privileges by directly attacking setuid, setgid, and</div><div class="line">   fcap-using binaries; it will need to compromise something without the</div><div class="line">   no_new_privs bit set first.</div></pre></td></tr></table></figure></p>
<p>“no_new_privs”主要应用在以下两个场景：</p>
<ul>
<li>已安装在seccomp模式2的沙盒过滤器可以持续在execve()(函数调用期间)改变新执行的程序的行为。no_new_privs设置后，只允许非特权用户安装过滤器。</li>
<li>就其本身而言，”no_new_privs”能够减小非法用户可进行攻击的攻击面。如果每一个进程都能够运行在设置了”no_new_privs”的UID下，这个UID就不会被”setuid”,”setgid”以及”fcap-using binaries”这些攻击手段提升权限;(为了避免权限提升)首先确保”no_new_privs”位能够提前设置。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">In the future, other potentially dangerous kernel features could become</div><div class="line">available to unprivileged tasks if no_new_privs is set.  In principle,</div><div class="line">several options to unshare(2) and clone(2) would be safe when</div><div class="line">no_new_privs is set, and no_new_privs + chroot is considerable less</div><div class="line">dangerous than chroot by itself.</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在未来，在”no_new_privs”模式下，将出现其他具有威胁内核的功能被非法的任务所应用。原则上，在”no_new_privs”模式下需要对unshare(2),以及clone(2)进行配置设置。实现”no_new_privs”与chroot的组合使用方式是一种相比与独立使用chroot的一种可实现的低风险方案。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The original article, please reference here &lt;a href=&quot;http://tomoyo.osdn.jp/cgi-bin/lxr/source/Documentation/prctl/no_new_privs.txt&quot; targe
    
    </summary>
    
      <category term="translation" scheme="https://turbin.github.io/categories/translation/"/>
    
    
      <category term="Linux kernel" scheme="https://turbin.github.io/tags/Linux-kernel/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="https://turbin.github.io/2016/09/14/Promise/"/>
    <id>https://turbin.github.io/2016/09/14/Promise/</id>
    <published>2016-09-14T12:30:45.000Z</published>
    <updated>2017-02-05T05:22:50.289Z</updated>
    
    <content type="html"><![CDATA[<p>由于项目开发需要解决JS同步的问题，但是受限在目前的框架里没有引用到jQuery，也就无法使用defered。也是自己嫌麻烦，于是开始重新造轮子的过程——服务于自己的测试代码，写了一个简易的promise的实现。</p>
<p><a href="https://github.com/turbin/JavascriptUtility.git" target="_blank" rel="external">Promise</a>下面有个src/Promise.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by turbineyan on 9/12/16.</div><div class="line"> */</div><div class="line">function Promise()&#123;</div><div class="line">&#125;</div><div class="line">Promise.prototype = &#123;</div><div class="line">    callback:null, caller:null,onDone:null,</div><div class="line">    when:function()&#123;</div><div class="line">        if(this.callbacks)&#123;</div><div class="line">            this.callbacks = null;</div><div class="line">        &#125;</div><div class="line">        this.callbacks = [];</div><div class="line">        this.caller = null;</div><div class="line">        for(var i=0; i!=arguments.length; i++)&#123;</div><div class="line">            this.callbacks.push(&#123;fn:arguments[i], onSuccess:this.onSuccess, onFail:this.fail&#125;);</div><div class="line">        &#125;</div><div class="line">        ///this.callbacks[this.idx].fn.call(this, this);</div><div class="line">        return this;</div><div class="line">    &#125;,</div><div class="line">    resolve:function()&#123;</div><div class="line">        this.next();</div><div class="line">        return this;</div><div class="line">    &#125;,</div><div class="line">    reject:function()&#123;</div><div class="line">        this.caller.onFail(this);</div><div class="line">        return this;</div><div class="line">    &#125;,</div><div class="line">    done:function(callback)&#123;</div><div class="line">        this.onDone = callback;</div><div class="line">        return this;</div><div class="line">    &#125;,</div><div class="line">    onSuccess:function(promise)&#123;</div><div class="line">        console.log(&apos;on success!&apos;);</div><div class="line">    &#125;,</div><div class="line">    next:function()&#123;</div><div class="line">        this.caller = null;</div><div class="line">        if(this.callbacks.length !== 0)&#123;</div><div class="line">            this.caller= this.callbacks.shift(1);</div><div class="line">            this.caller.fn(this);</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        if(this.onDone)this.onDone(this);</div><div class="line">        return this;</div><div class="line">    &#125;,</div><div class="line">    fail:function(promise) &#123;</div><div class="line">        var fn =this.caller.fn;</div><div class="line">        this.caller = null;</div><div class="line">        throw new EvalError(&apos;promise call &apos; + fn + &apos; call fail!&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>简单说明下，通过数组来组成一个链的结构。然后通过resovle和reject配合使用，实现类职责链的效果。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var promise = new Promise();</div><div class="line">promise.when(</div><div class="line">   function(promise)&#123; // step 1</div><div class="line">      // 在这里调用具体的函数实现，</div><div class="line">      // 如果成功，则执行promise.resolve()后，</div><div class="line">      // 执行链上的下一个函数，</div><div class="line">      // 如果失败,则调用promise.reject(),随后fail()会被执行</div><div class="line">      // 如果链上的所有步骤都成功，则最终执行done   </div><div class="line">   &#125;,</div><div class="line">).next()</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于项目开发需要解决JS同步的问题，但是受限在目前的框架里没有引用到jQuery，也就无法使用defered。也是自己嫌麻烦，于是开始重新造轮子的过程——服务于自己的测试代码，写了一个简易的promise的实现。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github
    
    </summary>
    
      <category term="coding" scheme="https://turbin.github.io/categories/coding/"/>
    
    
      <category term="JavaScript" scheme="https://turbin.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript Examples</title>
    <link href="https://turbin.github.io/2016/09/13/Javascript-Examples/"/>
    <id>https://turbin.github.io/2016/09/13/Javascript-Examples/</id>
    <published>2016-09-13T12:46:36.000Z</published>
    <updated>2017-02-05T05:23:06.301Z</updated>
    
    <content type="html"><![CDATA[<p>摘自《Javascript权威教程》</p>
<h3 id="Monkey-Path"><a href="#Monkey-Path" class="headerlink" title="Monkey Path"></a>Monkey Path</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function trace(o, m)&#123;</div><div class="line">   var original = o[m];</div><div class="line">   o[m] = function()&#123;</div><div class="line">        console.log(new Date(), &quot;Entering:&quot;, m);</div><div class="line">        var result = original.apply(this, arguments);</div><div class="line">        console.log(new Date(), &quot;Exiting:&quot;, m);</div><div class="line">        return result;</div><div class="line">   &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这种方法，更像是装饰器——动态添加了函数对象原本不支持的职责，缺不破坏函数本身。</p>
<h3 id="Bind方法"><a href="#Bind方法" class="headerlink" title="Bind方法:"></a>Bind方法:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">if(!Function.prototype.bind) &#123;</div><div class="line">   Function.prototype.bind = function(o /*, args */)&#123;</div><div class="line">      // 将this 和arguments 的值保存至变量中</div><div class="line">      // 以便后面嵌套的函数中可以使用它们</div><div class="line">      var self = this, boundArgs = arguments;</div><div class="line"></div><div class="line">      return function() &#123;</div><div class="line">           var args = [], i;</div><div class="line">           for(i=1; i &lt; boundArgs.length; i++) args.push(boundArgs[i]);</div><div class="line">           for(i=0; i &lt; arguments.length; i++) args.push(arguments[i]);</div><div class="line">           return self.apply(o, args);</div><div class="line">      &#125;;</div><div class="line">   &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是对使用ECMA-Script3 标准对ECMA-Script5标准的扩展。支持动态绑定，就像jQuery中的on方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘自《Javascript权威教程》&lt;/p&gt;
&lt;h3 id=&quot;Monkey-Path&quot;&gt;&lt;a href=&quot;#Monkey-Path&quot; class=&quot;headerlink&quot; title=&quot;Monkey Path&quot;&gt;&lt;/a&gt;Monkey Path&lt;/h3&gt;&lt;figure cla
    
    </summary>
    
      <category term="coding" scheme="https://turbin.github.io/categories/coding/"/>
    
    
      <category term="JavaScript" scheme="https://turbin.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
