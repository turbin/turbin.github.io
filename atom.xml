<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Turbine&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://turbin.github.io/"/>
  <updated>2017-02-05T06:00:51.378Z</updated>
  <id>https://turbin.github.io/</id>
  
  <author>
    <name>Turbine Yan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为了改版</title>
    <link href="https://turbin.github.io/2017/02/05/%E6%94%B9%E7%89%88/"/>
    <id>https://turbin.github.io/2017/02/05/改版/</id>
    <published>2017-02-05T05:25:00.000Z</published>
    <updated>2017-02-05T06:00:51.378Z</updated>
    
    <content type="html"><![CDATA[<h1 id="改版"><a href="#改版" class="headerlink" title="改版"></a>改版</h1><ol>
<li>修改模板，添加文章分类</li>
<li>添加文档分类包含，随笔，编程，文档翻译，以及笔记</li>
</ol>
<p>====================== 时间分隔线 =========================================<br>发现在国内配置 <strong><em>Ruby</em></strong> 的运行环境，是一种那么痛苦的领悟。本身我也不会 <strong><em>Ruby</em></strong>,配置gem也是种痛苦，出现问题了也不知道该怎么解决。只能祭出短平快的方法，直接上 <strong><em>Hexo</em></strong>，原因就是，大家都在用嘛。</p>
<p><strong><em>Hexo</em></strong> 只要配置NodeJs环境就够了，相对来说比较简单。虽然很多人诟病它生成速度太慢。特别是博客文章多了以后。</p>
<p>多等等，应该也无所谓了……</p>
<p>好吧，先祝福自己的博客改版快乐～～～</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;改版&quot;&gt;&lt;a href=&quot;#改版&quot; class=&quot;headerlink&quot; title=&quot;改版&quot;&gt;&lt;/a&gt;改版&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;修改模板，添加文章分类&lt;/li&gt;
&lt;li&gt;添加文档分类包含，随笔，编程，文档翻译，以及笔记&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;====
    
    </summary>
    
      <category term="essay" scheme="https://turbin.github.io/categories/essay/"/>
    
    
      <category term="杂谈" scheme="https://turbin.github.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>QWebkit源码阅读笔记(1)</title>
    <link href="https://turbin.github.io/2017/02/05/QWebkit%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB%E7%AC%94%E8%AE%B0(1)/"/>
    <id>https://turbin.github.io/2017/02/05/QWebkit源码走读笔记(1)/</id>
    <published>2017-02-05T03:45:45.000Z</published>
    <updated>2017-02-05T06:04:37.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文基于Qt5-5-1版本中的QWebkit"><a href="#本文基于Qt5-5-1版本中的QWebkit" class="headerlink" title="本文基于Qt5.5.1版本中的QWebkit"></a>本文基于Qt5.5.1版本中的QWebkit</h1><p>userAgent “Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/538.1 (KHTML, like Gecko) cordova Safari/538.1”</p>
<h1 id="页面加载的过程"><a href="#页面加载的过程" class="headerlink" title="页面加载的过程"></a>页面加载的过程</h1><h2 id="FrameLoader"><a href="#FrameLoader" class="headerlink" title="FrameLoader"></a>FrameLoader</h2><h3 id="FrameLoader-状态定义"><a href="#FrameLoader-状态定义" class="headerlink" title="FrameLoader-状态定义"></a>FrameLoader-状态定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">enum FrameState &#123;</div><div class="line">    FrameStateProvisional,</div><div class="line">    // This state indicates we are ready to commit to a page,</div><div class="line">    // which means the view will transition to use the new data source.</div><div class="line">    FrameStateCommittedPage,</div><div class="line">    FrameStateComplete</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="资源类型定义"><a href="#资源类型定义" class="headerlink" title="资源类型定义"></a>资源类型定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">enum Type &#123;</div><div class="line">    MainResource, // HTML</div><div class="line">    ImageResource, // 图片</div><div class="line">    CSSStyleSheet, // CSS文件</div><div class="line">    Script, // Javascript文件</div><div class="line">    FontResource, // 字体</div><div class="line">    RawResource // 其他包括多媒体文件等二进制文件</div><div class="line">#if ENABLE(SVG)</div><div class="line">    , SVGDocumentResource</div><div class="line">#endif</div><div class="line">#if ENABLE(XSLT)</div><div class="line">    , XSLStyleSheet</div><div class="line">#endif</div><div class="line">#if ENABLE(LINK_PREFETCH)</div><div class="line">    , LinkPrefetch</div><div class="line">    , LinkSubresource</div><div class="line">#endif</div><div class="line">#if ENABLE(VIDEO_TRACK)</div><div class="line">    , TextTrackResource</div><div class="line">#endif</div><div class="line">#if ENABLE(CSS_SHADERS)</div><div class="line">    , ShaderResource</div><div class="line">#endif</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在webkit中一般将HTML页面定义为主资源。</p>
<h3 id="FrameLoader-FrameState-FrameStateProvisional"><a href="#FrameLoader-FrameState-FrameStateProvisional" class="headerlink" title="FrameLoader::FrameState::FrameStateProvisional"></a>FrameLoader::FrameState::FrameStateProvisional</h3><p>Provisional 是Frame第一个定义状态,命名定义该状态是一个临时，且不确定状态<br>   TODO: 后续需要添加说明，该状态的命名原因；</p>
<h2 id="WebPage-gt-WebFrame-gt-FrameLoader的加载过程"><a href="#WebPage-gt-WebFrame-gt-FrameLoader的加载过程" class="headerlink" title="WebPage-&gt;WebFrame-&gt;FrameLoader的加载过程"></a>WebPage-&gt;WebFrame-&gt;FrameLoader的加载过程</h2><h4 id="Adapter层调用"><a href="#Adapter层调用" class="headerlink" title="Adapter层调用"></a>Adapter层调用</h4><ol>
<li><code>load -&gt; WebCore::Frame()-&gt;loader()</code>获得了 WebCore::FrameLoader</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">void QWebFrameAdapter::load(const QNetworkRequest&amp; req, QNetworkAccessManager::Operation operation, const QByteArray&amp; body)</div><div class="line">&#123;</div><div class="line">if (frame-&gt;tree()-&gt;parent())</div><div class="line">       pageAdapter-&gt;insideOpenCall = true;</div><div class="line"></div><div class="line">   QUrl url = ensureAbsoluteUrl(req.url());</div><div class="line"></div><div class="line">   WebCore::ResourceRequest request(url);</div><div class="line"></div><div class="line">   ... ...</div><div class="line"></div><div class="line">   frame-&gt;loader()-&gt;load(WebCore::FrameLoadRequest(frame, request));</div><div class="line"></div><div class="line">   if (frame-&gt;tree()-&gt;parent())</div><div class="line">       pageAdapter-&gt;insideOpenCall = false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><code>frame-&gt;loader()-&gt;load(WebCore::FrameLoadRequest(frame, request));</code><br>关键代码 <em>WebCore::FrameLoadRequest()</em> 调用的是 -&gt;  <code>FrameLoadRequest(Frame*, const ResourceRequest&amp;, const SubstituteData&amp; = SubstituteData())</code>;<br>这里WebCore::FrameLoadRequest().frameName() 返回的应该是空的string。</li>
<li><code>FrameLoadRequest(Frame*, const ResourceRequest&amp;, const SubstituteData&amp; = SubstituteData())</code>;<br>FrameLoader用空的SubstituteData去创建DocumentLoader，并使用DocumentLoader来完成MainResource的加载,SubstituteData用于在所请求的资源不可到达的时候，提供重定向指导。</li>
</ol>
<h4 id="通过FrameLoader-执行加载过程"><a href="#通过FrameLoader-执行加载过程" class="headerlink" title="通过FrameLoader 执行加载过程"></a>通过FrameLoader 执行加载过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">void FrameLoader::load(const FrameLoadRequest&amp; passedRequest)</div><div class="line">&#123;</div><div class="line">    FrameLoadRequest request(passedRequest);</div><div class="line"></div><div class="line">    if (m_inStopAllLoaders)</div><div class="line">        return;</div><div class="line"></div><div class="line">    if (!request.frameName().isEmpty()) &#123;</div><div class="line">        Frame* frame = findFrameForNavigation(request.frameName());</div><div class="line">        if (frame) &#123;</div><div class="line">            request.setShouldCheckNewWindowPolicy(false);</div><div class="line">            if (frame-&gt;loader() != this) &#123;</div><div class="line">                frame-&gt;loader()-&gt;load(request);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (request.shouldCheckNewWindowPolicy()) &#123;</div><div class="line">        policyChecker()-&gt;checkNewWindowPolicy(NavigationAction(request.resourceRequest(), NavigationTypeOther), FrameLoader::callContinueLoadAfterNewWindowPolicy, request.resourceRequest(), 0, request.frameName(), this);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!request.hasSubstituteData())</div><div class="line">        request.setSubstituteData(defaultSubstituteDataForURL(request.resourceRequest().url()));</div><div class="line"></div><div class="line">    RefPtr&lt;DocumentLoader&gt; loader = m_client-&gt;createDocumentLoader(request.resourceRequest(), request.substituteData());</div><div class="line">    if (request.lockHistory() &amp;&amp; m_documentLoader)</div><div class="line">        loader-&gt;setClientRedirectSourceForHistory(m_documentLoader-&gt;didCreateGlobalHistoryEntry() ? m_documentLoader-&gt;urlForHistory().string() : m_documentLoader-&gt;clientRedirectSourceForHistory());</div><div class="line">    load(loader.get());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>建立一个documentloader来加载资源：RefPtr<documentloader> loader = m_client-&gt;createDocumentLoader(request.resourceRequest(), request.substituteData());<br>注意这里的request.subtitueData是一个空对象。<br>然后调用：</documentloader></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">void FrameLoader::load(DocumentLoader* newDocumentLoader)</div><div class="line">&#123;</div><div class="line">    ……</div><div class="line">    if (m_documentLoader)</div><div class="line">        newDocumentLoader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());</div><div class="line"></div><div class="line">    // When we loading alternate content for an unreachable URL that we&apos;re</div><div class="line">    // visiting in the history list, we treat it as a reload so the history list</div><div class="line">    // is appropriately maintained.</div><div class="line">    //</div><div class="line">    // FIXME: This seems like a dangerous overloading of the meaning of &quot;FrameLoadTypeReload&quot; ...</div><div class="line">    // shouldn&apos;t a more explicit type of reload be defined, that means roughly</div><div class="line">    // &quot;load without affecting history&quot; ?</div><div class="line">    if (shouldReloadToHandleUnreachableURL(newDocumentLoader)) &#123;</div><div class="line">        // shouldReloadToHandleUnreachableURL() returns true only when the original load type is back-forward.</div><div class="line">        // In this case we should save the document state now. Otherwise the state can be lost because load type is</div><div class="line">        // changed and updateForBackForwardNavigation() will not be called when loading is committed.</div><div class="line">        history()-&gt;saveDocumentAndScrollState();</div><div class="line">        ASSERT(type == FrameLoadTypeStandard);</div><div class="line">        type = FrameLoadTypeReload;</div><div class="line">    &#125;</div><div class="line">    loadWithDocumentLoader(newDocumentLoader, type, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里的问题：<br>if (m_documentLoader)<br>        newDocumentLoader-&gt;setOverrideEncoding(m_documentLoader-&gt;overrideEncoding());</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 这里是m_documentLoader在FrameLoader中的定义：</div><div class="line">// Document loaders for the three phases of frame loading. Note that while</div><div class="line">// a new request is being loaded, the old document loader may still be referenced.</div><div class="line">// E.g. while a new request is in the &quot;policy&quot; state, the old document loader may</div><div class="line">// be consulted in particular as it makes sense to imply certain settings on the new loader.</div><div class="line">RefPtr&lt;DocumentLoader&gt; m_documentLoader;</div></pre></td></tr></table></figure>
<p><strong><em>在frame 加载的过程中的三个不同阶段，都将创建并调用到document loader这个类型。请注意一个新的请求正在被加载的时候，先前的document loader可能依然会被其他对象引用到。<br>比如，一个新的请求还处于”policy”这个状态时，新的loader依然会关联到先前的document loader中一些具体配置参数</em></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">void FrameLoader::loadWithDocumentLoader(DocumentLoader* loader, FrameLoadType type, PassRefPtr&lt;FormState&gt; prpFormState)</div><div class="line">&#123;</div><div class="line"></div><div class="line">    // Retain because dispatchBeforeLoadEvent may release the last reference to it.</div><div class="line">    RefPtr&lt;Frame&gt; protect(m_frame);</div><div class="line">    ASSERT(m_client-&gt;hasWebView()); // 所以页面在加载前会判断当前的client中是否包含了View的实现。</div><div class="line">    ……</div><div class="line"></div><div class="line">    if (shouldPerformFragmentNavigation(isFormSubmission, httpMethod, policyChecker()-&gt;loadType(), newURL)) &#123;</div><div class="line">        RefPtr&lt;DocumentLoader&gt; oldDocumentLoader = m_documentLoader;</div><div class="line">        NavigationAction action(loader-&gt;request(), policyChecker()-&gt;loadType(), isFormSubmission);</div><div class="line">        oldDocumentLoader-&gt;setTriggeringAction(action);</div><div class="line">        policyChecker()-&gt;stopCheck();</div><div class="line">        policyChecker()-&gt;checkNavigationPolicy(loader-&gt;request(), oldDocumentLoader.get(), formState,</div><div class="line">            callContinueFragmentScrollAfterNavigationPolicy, this);</div><div class="line">    &#125; else &#123;</div><div class="line">        if (Frame* parent = m_frame-&gt;tree()-&gt;parent())</div><div class="line">            loader-&gt;setOverrideEncoding(parent-&gt;loader()-&gt;documentLoader()-&gt;overrideEncoding());</div><div class="line">        policyChecker()-&gt;stopCheck();</div><div class="line">        // 将新创建的documentloader设置给m_policyDocumentLoader</div><div class="line">        setPolicyDocumentLoader(loader);</div><div class="line">        if (loader-&gt;triggeringAction().isEmpty())</div><div class="line">            // 将本次加载的请求记录在loader的m_triggeringAction中</div><div class="line">            loader-&gt;setTriggeringAction(NavigationAction(loader-&gt;request(), policyChecker()-&gt;loadType(), isFormSubmission));</div><div class="line">        if (Element* ownerElement = m_frame-&gt;ownerElement()) &#123;</div><div class="line">            // We skip dispatching the beforeload event if we&apos;ve already</div><div class="line">            // committed a real document load because the event would leak</div><div class="line">            // subsequent activity by the frame which the parent frame isn&apos;t</div><div class="line">            // supposed to learn. For example, if the child frame navigated to</div><div class="line">            // a new URL, the parent frame shouldn&apos;t learn the URL.</div><div class="line">            if (!m_stateMachine.committedFirstRealDocumentLoad()</div><div class="line">                &amp;&amp; !ownerElement-&gt;dispatchBeforeLoadEvent(loader-&gt;request().url().string())) &#123;</div><div class="line">                continueLoadAfterNavigationPolicy(loader-&gt;request(), formState, false);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 使用前面记录的loader.m_triggeringAction做校验，处理空白，重复，不可到达的请求，</div><div class="line">        // 该校验还要包括FrameLoaderClient实现的一些检查，以决定如何处理本次请求。</div><div class="line">        policyChecker()-&gt;checkNavigationPolicy(loader-&gt;request(), loader, formState,</div><div class="line">            callContinueLoadAfterNavigationPolicy, this);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong><em>设置完成以后，通过<code>policyChecker()</code>校验请求后，调用<code>callContinueLoadAfterNavigationPolicy()</code>。<br>在<code>callContinueLoadAfterNavigationPolicy()</code> 中将设置FrameLoader的状态转换为</em>Provisional<em>。<a href="/FrameLoader-状态定义/">参考FrameLoader的状态定义</a></em></strong><br>这是一个简单 包裹方法，简单地做了一个转换。实际调用的是continueLoadAfterNavigationPolicy。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void FrameLoader::callContinueLoadAfterNavigationPolicy(void* argument,</div><div class="line">    const ResourceRequest&amp; request, PassRefPtr&lt;FormState&gt; formState, bool shouldContinue)</div><div class="line">&#123;</div><div class="line">    FrameLoader* loader = static_cast&lt;FrameLoader*&gt;(argument);</div><div class="line">    loader-&gt;continueLoadAfterNavigationPolicy(request, formState, shouldContinue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="关于-continueLoadAfterNavigationPolicy-说明"><a href="#关于-continueLoadAfterNavigationPolicy-说明" class="headerlink" title="关于 continueLoadAfterNavigationPolicy()说明"></a>关于 <code>continueLoadAfterNavigationPolicy()</code>说明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">void FrameLoader::continueLoadAfterNavigationPolicy(const ResourceRequest&amp;, PassRefPtr&lt;FormState&gt; formState, bool shouldContinue)</div><div class="line">&#123;</div><div class="line">    // If we loaded an alternate page to replace an unreachableURL, we&apos;ll get in here with a</div><div class="line">    // nil policyDataSource because loading the alternate page will have passed</div><div class="line">    // through this method already, nested; otherwise, policyDataSource should still be set.</div><div class="line">    ASSERT(m_policyDocumentLoader || !m_provisionalDocumentLoader-&gt;unreachableURL().isEmpty());</div><div class="line"></div><div class="line">    bool isTargetItem = history()-&gt;provisionalItem() ? history()-&gt;provisionalItem()-&gt;isTargetItem() : false;</div><div class="line"></div><div class="line">    // Two reasons we can&apos;t continue:</div><div class="line">    //    1) Navigation policy delegate said we can&apos;t so request is nil. A primary case of this</div><div class="line">    //       is the user responding Cancel to the form repost nag sheet.</div><div class="line">    //    2) User responded Cancel to an alert popped up by the before unload event handler.</div><div class="line">    bool canContinue = shouldContinue &amp;&amp; shouldClose();</div><div class="line"></div><div class="line">    if (!canContinue) &#123;</div><div class="line">        // If we were waiting for a quick redirect, but the policy delegate decided to ignore it, then we</div><div class="line">        // need to report that the client redirect was cancelled.</div><div class="line">        if (m_quickRedirectComing)</div><div class="line">            clientRedirectCancelledOrFinished(false);</div><div class="line"></div><div class="line">        setPolicyDocumentLoader(0);</div><div class="line"></div><div class="line">        // If the navigation request came from the back/forward menu, and we punt on it, we have the</div><div class="line">        // problem that we have optimistically moved the b/f cursor already, so move it back.  For sanity,</div><div class="line">        // we only do this when punting a navigation for the target frame or top-level frame.  </div><div class="line">        if ((isTargetItem || isLoadingMainFrame()) &amp;&amp; isBackForwardLoadType(policyChecker()-&gt;loadType())) &#123;</div><div class="line">            if (Page* page = m_frame-&gt;page()) &#123;</div><div class="line">                Frame* mainFrame = page-&gt;mainFrame();</div><div class="line">                if (HistoryItem* resetItem = mainFrame-&gt;loader()-&gt;history()-&gt;currentItem()) &#123;</div><div class="line">                    page-&gt;backForward()-&gt;setCurrentItem(resetItem);</div><div class="line">                    m_frame-&gt;loader()-&gt;client()-&gt;updateGlobalHistoryItemForPage();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    FrameLoadType type = policyChecker()-&gt;loadType();</div><div class="line">    // A new navigation is in progress, so don&apos;t clear the history&apos;s provisional item.</div><div class="line">    stopAllLoaders(ShouldNotClearProvisionalItem);</div><div class="line"></div><div class="line">    // &lt;rdar://problem/6250856&gt; - In certain circumstances on pages with multiple frames, stopAllLoaders()</div><div class="line">    // might detach the current FrameLoader, in which case we should bail on this newly defunct load.</div><div class="line">    if (!m_frame-&gt;page())</div><div class="line">        return;</div><div class="line"></div><div class="line">#if ENABLE(JAVASCRIPT_DEBUGGER) &amp;&amp; ENABLE(INSPECTOR)</div><div class="line">    if (Page* page = m_frame-&gt;page()) &#123;</div><div class="line">        if (page-&gt;mainFrame() == m_frame)</div><div class="line">            m_frame-&gt;page()-&gt;inspectorController()-&gt;resume();</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line"></div><div class="line">    setProvisionalDocumentLoader(m_policyDocumentLoader.get());</div><div class="line">    m_loadType = type;</div><div class="line">    setState(FrameStateProvisional);</div><div class="line"></div><div class="line">    setPolicyDocumentLoader(0);</div><div class="line"></div><div class="line">    if (isBackForwardLoadType(type) &amp;&amp; history()-&gt;provisionalItem()-&gt;isInPageCache()) &#123;</div><div class="line">        loadProvisionalItemFromCachedPage();</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    ///</div><div class="line">    if (formState)</div><div class="line">        m_client-&gt;dispatchWillSubmitForm(&amp;PolicyChecker::continueLoadAfterWillSubmitForm, formState);</div><div class="line">    else</div><div class="line">        continueLoadAfterWillSubmitForm();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  在继续执行加载的策略中判断，用户是否取消加载，如果取消加载则将已加载的内容替换成缓存中的历史记录<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">// Two reasons we can&apos;t continue:</div><div class="line">//    1) Navigation policy delegate said we can&apos;t so request is nil. A primary case of this</div><div class="line">//       is the user responding Cancel to the form repost nag sheet.</div><div class="line">//    2) User responded Cancel to an alert popped up by the before unload event handler.</div><div class="line">bool canContinue = shouldContinue &amp;&amp; shouldClose();</div><div class="line"></div><div class="line">if (!canContinue) &#123;</div><div class="line">    // If we were waiting for a quick redirect, but the policy delegate decided to ignore it, then we</div><div class="line">    // need to report that the client redirect was cancelled.</div><div class="line">    if (m_quickRedirectComing)</div><div class="line">        clientRedirectCancelledOrFinished(false);</div><div class="line"></div><div class="line">    setPolicyDocumentLoader(0);</div><div class="line"></div><div class="line">    // If the navigation request came from the back/forward menu, and we punt on it, we have the</div><div class="line">    // problem that we have optimistically moved the b/f cursor already, so move it back.  For sanity,</div><div class="line">    // we only do this when punting a navigation for the target frame or top-level frame.  </div><div class="line">    if ((isTargetItem || isLoadingMainFrame()) &amp;&amp; isBackForwardLoadType(policyChecker()-&gt;loadType())) &#123;</div><div class="line">        if (Page* page = m_frame-&gt;page()) &#123;</div><div class="line">            Frame* mainFrame = page-&gt;mainFrame();</div><div class="line">            if (HistoryItem* resetItem = mainFrame-&gt;loader()-&gt;history()-&gt;currentItem()) &#123;</div><div class="line">                page-&gt;backForward()-&gt;setCurrentItem(resetItem);</div><div class="line">                m_frame-&gt;loader()-&gt;client()-&gt;updateGlobalHistoryItemForPage();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  如果用户未取消加载操作，则根据表单状态，执行后续流程。一般都是走<code>else</code>这个分支。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (formState)</div><div class="line">   m_client-&gt;dispatchWillSubmitForm(&amp;PolicyChecker::continueLoadAfterWillSubmitForm, formState);</div><div class="line">else</div><div class="line">   continueLoadAfterWillSubmitForm();</div></pre></td></tr></table></figure></p>
<p>接着开始进入页面的真正加载流程。</p>
<h4 id="开始加载页面"><a href="#开始加载页面" class="headerlink" title="开始加载页面"></a>开始加载页面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">void FrameLoader::continueLoadAfterWillSubmitForm()</div><div class="line">&#123;</div><div class="line">    if (!m_provisionalDocumentLoader)</div><div class="line">        return;</div><div class="line"></div><div class="line">    prepareForLoadStart();</div><div class="line"></div><div class="line">    // The load might be cancelled inside of prepareForLoadStart(), nulling out the m_provisionalDocumentLoader,</div><div class="line">    // so we need to null check it again.</div><div class="line">    if (!m_provisionalDocumentLoader)</div><div class="line">        return;</div><div class="line"></div><div class="line">    DocumentLoader* activeDocLoader = activeDocumentLoader();</div><div class="line">    if (activeDocLoader &amp;&amp; activeDocLoader-&gt;isLoadingMainResource())</div><div class="line">        return;</div><div class="line"></div><div class="line">    m_loadingFromCachedPage = false;</div><div class="line">    m_provisionalDocumentLoader-&gt;startLoadingMainResource();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><p><code>prepareForLoadStart();</code> 通知进度条进行加载准备，向client 分发消息通知进行加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void FrameLoader::prepareForLoadStart()</div><div class="line">&#123;</div><div class="line">   m_progressTracker-&gt;progressStarted();</div><div class="line">   m_client-&gt;dispatchDidStartProvisionalLoad();</div><div class="line">   ... ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><code>m_provisionalDocumentLoader-&gt;startLoadingMainResource();</code> 开始将首页面作为主资源进行加载，<br>这里实际调用的是DocumentLoader::startLoadingMainResource;</p>
</li>
</ol>
<h3 id="DocumentLoader"><a href="#DocumentLoader" class="headerlink" title="DocumentLoader"></a>DocumentLoader</h3><p>所有资源的加载，都是通过DocumentLoader 以及子类实现的;<br>m_provisionalDocumentLoader 就是一个DocumentLoader;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">void DocumentLoader::startLoadingMainResource()</div><div class="line">&#123;</div><div class="line">    ... ...</div><div class="line"></div><div class="line">    ResourceRequest request(m_request);</div><div class="line">    DEFINE_STATIC_LOCAL(ResourceLoaderOptions, mainResourceLoadOptions,</div><div class="line">        (SendCallbacks, SniffContent, BufferData, AllowStoredCredentials, AskClientForAllCredentials, SkipSecurityCheck, UseDefaultOriginRestrictionsForType));</div><div class="line">    CachedResourceRequest cachedResourceRequest(request, mainResourceLoadOptions);</div><div class="line"></div><div class="line">    m_mainResource = m_cachedResourceLoader-&gt;requestMainResource(cachedResourceRequest);</div><div class="line">    if (!m_mainResource) &#123;</div><div class="line">        setRequest(ResourceRequest());</div><div class="line">        // If the load was aborted by clearing m_request, it&apos;s possible the ApplicationCacheHost</div><div class="line">        // is now in a state where starting an empty load will be inconsistent. Replace it with</div><div class="line">        // a new ApplicationCacheHost.</div><div class="line">        m_applicationCacheHost = adoptPtr(new ApplicationCacheHost(this));</div><div class="line">        maybeLoadEmpty();</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!mainResourceLoader()) &#123;</div><div class="line">        m_identifierForLoadWithoutResourceLoader = m_frame-&gt;page()-&gt;progress()-&gt;createUniqueIdentifier();</div><div class="line">        frameLoader()-&gt;notifier()-&gt;assignIdentifierToInitialRequest(m_identifierForLoadWithoutResourceLoader, this, request);</div><div class="line">        frameLoader()-&gt;notifier()-&gt;dispatchWillSendRequest(this, m_identifierForLoadWithoutResourceLoader, request, ResourceResponse());</div><div class="line">    &#125;</div><div class="line">    m_mainResource-&gt;addClient(this);</div><div class="line"></div><div class="line">    // A bunch of headers are set when the underlying ResourceLoader is created, and m_request needs to include those.</div><div class="line">    if (mainResourceLoader())</div><div class="line">        request = mainResourceLoader()-&gt;originalRequest();</div><div class="line">    // If there was a fragment identifier on m_request, the cache will have stripped it. m_request should include</div><div class="line">    // the fragment identifier, so add that back in.</div><div class="line">    if (equalIgnoringFragmentIdentifier(m_request.url(), request.url()))</div><div class="line">        request.setURL(m_request.url());</div><div class="line">    setRequest(request);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><strong><em><code>关于ResourceRequest request(m_request);</code></em></strong><br>这里仅仅是将指针值赋值给新的request 还是将整个m_request 的内容都拷贝给了request？<br>如果是整个内容都拷贝给了request,那么下面执行的语句：<figure class="highlight plain"><figcaption><span>If there was a fragment identifier on m_request, the cache will have stripped it. m_request should include</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// the fragment identifier, so add that back in.</div><div class="line">if (equalIgnoringFragmentIdentifier(m_request.url(), request.url()))</div><div class="line">    request.setURL(m_request.url());</div></pre></td></tr></table></figure>
</li>
</ol>
<p>不是太理解这边的执行内容。</p>
<ol>
<li><p>在这里通过创建mainResource,然后将自己注册给mainResource作为回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">line 1382:</div><div class="line">m_mainResource = m_cachedResourceLoader-&gt;requestMainResource(cachedResourceRequest);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">line 1398:</div><div class="line">m_mainResource-&gt;addClient(this);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>接着就将请求转向了<code>CachedResourceLoader</code>。</p>
<h3 id="CachedResourceLoader"><a href="#CachedResourceLoader" class="headerlink" title="CachedResourceLoader"></a>CachedResourceLoader</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 注释说明：</div><div class="line">// The CachedResourceLoader provides a per-context interface to the MemoryCache</div><div class="line">// and enforces a bunch of security checks and rules for resource revalidation.</div><div class="line">// Its lifetime is roughly per-DocumentLoader, in that it is generally created</div><div class="line">// in the DocumentLoader constructor and loses its ability to generate network</div><div class="line">// requests when the DocumentLoader is destroyed. Documents also hold a</div><div class="line">// RefPtr&lt;CachedResourceLoader&gt; for their lifetime (and will create one if they</div><div class="line">// are initialized without a Frame), so a Document can keep a CachedResourceLoader</div><div class="line">// alive past detach if scripts still reference the Document.</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CachedResourceHandle&lt;CachedRawResource&gt; CachedResourceLoader::requestMainResource(CachedResourceRequest&amp; request)</div><div class="line">&#123;</div><div class="line">    return static_cast&lt;CachedRawResource*&gt;(requestResource(CachedResource::MainResource, request).get());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过调用requestResource 来向服务端请求<a href="/资源类型定义/">主资源</a>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">CachedResourceHandle&lt;CachedResource&gt; CachedResourceLoader::requestResource(CachedResource::Type type, CachedResourceRequest&amp; request)</div><div class="line">&#123;</div><div class="line">    // 判断是否由缓存中预取得到相应的资源对象</div><div class="line">    ... ...</div><div class="line"></div><div class="line">    const RevalidationPolicy policy = determineRevalidationPolicy(type, request.mutableResourceRequest(), request.forPreload(), resource.get(), request.defer());</div><div class="line">    switch (policy) &#123;</div><div class="line">    case Reload:</div><div class="line">        memoryCache()-&gt;remove(resource.get());</div><div class="line">        // Fall through</div><div class="line">    case Load:</div><div class="line">        resource = loadResource(type, request, request.charset());</div><div class="line">        break;</div><div class="line">    case Revalidate:</div><div class="line">        resource = revalidateResource(request, resource.get());</div><div class="line">        break;</div><div class="line">    case Use:</div><div class="line">        if (!shouldContinueAfterNotifyingLoadedFromMemoryCache(resource.get()))</div><div class="line">            return 0;</div><div class="line">        memoryCache()-&gt;resourceAccessed(resource.get());</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ... ...</div><div class="line"></div><div class="line">    if ((policy != Use || resource-&gt;stillNeedsLoad()) &amp;&amp; CachedResourceRequest::NoDefer == request.defer()) &#123;</div><div class="line">        resource-&gt;load(this, request.options());</div><div class="line"></div><div class="line">        // We don&apos;t support immediate loads, but we do support immediate failure.</div><div class="line">        if (resource-&gt;errorOccurred()) &#123;</div><div class="line">            if (resource-&gt;inCache())</div><div class="line">                memoryCache()-&gt;remove(resource.get());</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ... ...</div><div class="line">    return resource;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>const RevalidationPolicy policy = determineRevalidationPolicy(type, request.mutableResourceRequest(), request.forPreload(), resource.get(), request.defer());</code> 这里通过封装的加载策略，来判断加载方式。<br>加载的策略方式有 reLoad, Revalidate, Use, Load。<br>这里仅分析在Load的情况，其他情况待分解。<br><code>resource = loadResource(type, request, request.charset());</code> 该函数调用了<code>static CachedResource* createResource(CachedResource::Type type, ResourceRequest&amp; request, const String&amp; charset)</code><br>来创建指定的资源类型，并将其返回。<br>然后程序执行到这句：<br><code>if ((policy != Use || resource-&gt;stillNeedsLoad()) &amp;&amp; CachedResourceRequest::NoDefer == request.defer()) {
        resource-&gt;load(this, request.options());</code><br>新加载的资源对应策略为load,并且主资源未设置Defer,resource-&gt;stillNeedsLoad(),默认情况下都返回False。<br><strong><em>所以<code>policy != Use</code> 与 <code>CachedResourceRequest::NoDefer == request.defer()</code>同时命中，执行resource-&gt;load方法。</em></strong><br>执行<code>CachedResource::load(CachedResourceLoader* cachedResourceLoader, const ResourceLoaderOptions&amp; options)</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void CachedResource::load(CachedResourceLoader* cachedResourceLoader, const ResourceLoaderOptions&amp; options)</div><div class="line">&#123;</div><div class="line">    // 此处忽略若干行</div><div class="line">    ... ...</div><div class="line"></div><div class="line">    m_loader = platformStrategies()-&gt;loaderStrategy()-&gt;resourceLoadScheduler()-&gt;scheduleSubresourceLoad(cachedResourceLoader-&gt;frame(), this, request, request.priority(), options);</div><div class="line">    if (!m_loader) &#123;</div><div class="line">        failBeforeStarting();</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    m_status = Pending;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于webkit需要支持不同的平台，所以将不同平台下资源加载的方式使用策略模式进行了封装。然后将资源调用通过resourceLoadScheduler来统一请求和调度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">PassRefPtr&lt;SubresourceLoader&gt; ResourceLoadScheduler::scheduleSubresourceLoad(Frame* frame, CachedResource* resource, const ResourceRequest&amp; request, ResourceLoadPriority priority, const ResourceLoaderOptions&amp; options)</div><div class="line">&#123;</div><div class="line">    RefPtr&lt;SubresourceLoader&gt; loader = SubresourceLoader::create(frame, resource, request, options);</div><div class="line">    if (loader)</div><div class="line">        scheduleLoad(loader.get(), priority);</div><div class="line">    return loader.release();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里创建了一个资源调度器，进行加载调用。<br>从CachedResource::load -&gt; ResourceLoadScheduler::scheduleSubresourceLoad 这里的调用流程与其他派生资源(如图片、CSS文件、JS文件等)的加载是同一个流程。</p>
<h1 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h1><h3 id="Document-对象的三个状态具体转换过程"><a href="#Document-对象的三个状态具体转换过程" class="headerlink" title="Document 对象的三个状态具体转换过程"></a>Document 对象的三个状态具体转换过程</h3><p>在Javascript中页面的DOM加载经历三个状态， loading, interactive, complete。<br>三个状态定义在Document中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">// 三个状态通过readyState 接口返回</div><div class="line">String Document::readyState() const</div><div class="line">&#123;</div><div class="line">    DEFINE_STATIC_LOCAL(const String, loading, (ASCIILiteral(&quot;loading&quot;)));</div><div class="line">    DEFINE_STATIC_LOCAL(const String, interactive, (ASCIILiteral(&quot;interactive&quot;)));</div><div class="line">    DEFINE_STATIC_LOCAL(const String, complete, (ASCIILiteral(&quot;complete&quot;)));</div><div class="line">    switch (m_readyState) &#123;</div><div class="line">    case Loading:</div><div class="line">        return loading;</div><div class="line">    case Interactive:</div><div class="line">        return interactive;</div><div class="line">    case Complete:</div><div class="line">        return complete;</div><div class="line">    &#125;</div><div class="line">    ASSERT_NOT_REACHED();</div><div class="line">    return String();</div><div class="line">&#125;</div><div class="line">// 三个状态通过setReadyState接口进行更改</div><div class="line">void Document::setReadyState(ReadyState readyState)</div><div class="line">&#123;</div><div class="line">    if (readyState == m_readyState)</div><div class="line">        return;</div><div class="line">    switch (readyState) &#123;</div><div class="line">    case Loading:</div><div class="line">        if (!m_documentTiming.domLoading)</div><div class="line">            m_documentTiming.domLoading = monotonicallyIncreasingTime();</div><div class="line">        break;</div><div class="line">    case Interactive:</div><div class="line">        if (!m_documentTiming.domInteractive)</div><div class="line">            m_documentTiming.domInteractive = monotonicallyIncreasingTime();</div><div class="line">        break;</div><div class="line">    case Complete:</div><div class="line">        if (!m_documentTiming.domComplete)</div><div class="line">            m_documentTiming.domComplete = monotonicallyIncreasingTime();</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">    m_readyState = readyState;</div><div class="line">    /// COMMENT 通知页面上的监听者(JS)</div><div class="line">    dispatchEvent(Event::create(eventNames().readystatechangeEvent, false, false));</div><div class="line"></div><div class="line">    if (settings() &amp;&amp; settings()-&gt;suppressesIncrementalRendering())</div><div class="line">        setVisualUpdatesAllowed(readyState);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文基于Qt5-5-1版本中的QWebkit&quot;&gt;&lt;a href=&quot;#本文基于Qt5-5-1版本中的QWebkit&quot; class=&quot;headerlink&quot; title=&quot;本文基于Qt5.5.1版本中的QWebkit&quot;&gt;&lt;/a&gt;本文基于Qt5.5.1版本中的QWebk
    
    </summary>
    
      <category term="notes" scheme="https://turbin.github.io/categories/notes/"/>
    
    
      <category term="Webkit源码阅读" scheme="https://turbin.github.io/tags/Webkit%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>关于 no_new_privs 说明</title>
    <link href="https://turbin.github.io/2017/01/28/no_new_privs%E4%B8%AD%E6%96%87%E8%AF%B4%E6%98%8E%E7%BF%BB%E8%AF%91/"/>
    <id>https://turbin.github.io/2017/01/28/no_new_privs中文说明翻译/</id>
    <published>2017-01-28T12:30:45.000Z</published>
    <updated>2017-02-05T05:20:26.603Z</updated>
    
    <content type="html"><![CDATA[<p>The original article, please reference here <a href="http://tomoyo.osdn.jp/cgi-bin/lxr/source/Documentation/prctl/no_new_privs.txt" target="_blank" rel="external">no_new_privs.txt</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The execve system call can grant a newly-started program privileges that</div><div class="line">its parent did not have.</div></pre></td></tr></table></figure></p>
<p>execve 系统调用能够赋予最新启动的进程其父进程没有的权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">The most obvious examples are setuid/setgid</div><div class="line">programs and file capabilities.  To prevent the parent program from</div><div class="line">gaining these privileges as well, the kernel and user code must be</div><div class="line">careful to prevent the parent from doing anything that could subvert the</div><div class="line">child.</div></pre></td></tr></table></figure></p>
<p>最常见的例子就是通过 setuid和setgid来设置程序进程的uid以及gid以及文件的访问权限。(子进程)同样继承了父进程的权限，在内核以及用户代码中必须小心这些权限信息，避免造成子进程崩溃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">For example:</div><div class="line"></div><div class="line"> - The dynamic loader handles LD_* environment variables differently if</div><div class="line">   a program is setuid.</div><div class="line"></div><div class="line"> - chroot is disallowed to unprivileged processes, since it would allow</div><div class="line">   /etc/passwd to be replaced from the point of view of a process that</div><div class="line">   inherited chroot.</div><div class="line"></div><div class="line"> - The exec code has special handling for ptrace.</div></pre></td></tr></table></figure>
<p>例如：</p>
<ul>
<li><p>一个被重新设置了uid的程序，(启动运行时)动态链接器在处理这些以”LD_”为前缀的环境变量时，要注意(其文件路径的权限)差异；</p>
</li>
<li><p>使用chroot生成的进程，它所加载的/etc/passwd文件所指向的路径将会(不同的root运行环境所)变更。因此chroot会禁止那些(在新环境下)未定义权限的进程运行；</p>
</li>
<li><p>使用ptrace来跟踪指定的代码；</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">These are all ad-hoc fixes.  The no_new_privs bit (since Linux 3.5) is a</div><div class="line">new, generic mechanism to make it safe for a process to modify its</div><div class="line">execution environment in a manner that persists across execve.  Any task</div><div class="line">can set no_new_privs.  Once the bit is set, it is inherited across fork,</div><div class="line">clone, and execve and cannot be unset.  With no_new_privs set, execve</div><div class="line">promises not to grant the privilege to do anything that could not have</div><div class="line">been done without the execve call.  For example, the setuid and setgid</div><div class="line">bits will no longer change the uid or gid; file capabilities will not</div><div class="line">add to the permitted set, and LSMs will not relax constraints after</div><div class="line">execve.</div></pre></td></tr></table></figure>
<p>因此内核引入了一些临时性解决方案。到后来，内核(从 Linux3.5版本开始)引入(设置)”no_new_privs”位的全新的通用机制，提供给进程一种能够在execve()调用整个阶段都能持续有效且安全的方法。任何一个进程都可以设置”no_new_privs”位。然而一旦(当前进程)被置位，不论通过fork,clone,或者execve生成的子进程都无法将该位清零。因此通过”no_new_privs”置位的方式，execve函数可以确保所有的操作都必须调用execve()(判定)赋予权限后才被执行。比如，<br>  setuid和setgid操作将无法有效执行；<br>  文件访问权限无法被扩增，LINUX安全模块(LSM-Linux Security Module)在execve()执行后不会释放控制权限；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">To set no_new_privs, use prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0).</div></pre></td></tr></table></figure>
<p>设置”no_new_privs”位，可以这样调用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Be careful, though: LSMs might also not tighten constraints on exec</div><div class="line">in no_new_privs mode.  (This means that setting up a general-purpose</div><div class="line">service launcher to set no_new_privs before execing daemons may</div><div class="line">interfere with LSM-based sandboxing.)</div></pre></td></tr></table></figure>
<p>要注意到的是，因此：处于”no_new_privs”模式下,调用exec()函数时，Linux安全模块将收紧权限控制。<br>(这意味着建立一个通用启动器，在设置no_new_privs之前execing守护进程可能会受到LSM沙盒的影响)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Note that no_new_privs does not prevent privilege changes that do not</div><div class="line">involve execve.  An appropriately privileged task can still call</div><div class="line">setuid(2) and receive SCM_RIGHTS datagrams.</div></pre></td></tr></table></figure></p>
<p>注意，通过execve调用，可以确保处于”no_new_privs”模式(下的进程)权限不发生变化。一个适当的特权任务，可以持续完成uid设置，以及接收SCM_RIGHTS报文数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">There are two main use cases for no_new_privs so far:</div><div class="line"></div><div class="line"> - Filters installed for the seccomp mode 2 sandbox persist across</div><div class="line">   execve and can change the behavior of newly-executed programs.</div><div class="line">   Unprivileged users are therefore only allowed to install such filters</div><div class="line">   if no_new_privs is set.</div><div class="line"></div><div class="line"> - By itself, no_new_privs can be used to reduce the attack surface</div><div class="line">   available to an unprivileged user.  If everything running with a</div><div class="line">   given uid has no_new_privs set, then that uid will be unable to</div><div class="line">   escalate its privileges by directly attacking setuid, setgid, and</div><div class="line">   fcap-using binaries; it will need to compromise something without the</div><div class="line">   no_new_privs bit set first.</div></pre></td></tr></table></figure></p>
<p>“no_new_privs”主要应用在以下两个场景：</p>
<ul>
<li>已安装在seccomp模式2的沙盒过滤器可以持续在execve()(函数调用期间)改变新执行的程序的行为。no_new_privs设置后，只允许非特权用户安装过滤器。</li>
<li>就其本身而言，”no_new_privs”能够减小非法用户可进行攻击的攻击面。如果每一个进程都能够运行在设置了”no_new_privs”的UID下，这个UID就不会被”setuid”,”setgid”以及”fcap-using binaries”这些攻击手段提升权限;(为了避免权限提升)首先确保”no_new_privs”位能够提前设置。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">In the future, other potentially dangerous kernel features could become</div><div class="line">available to unprivileged tasks if no_new_privs is set.  In principle,</div><div class="line">several options to unshare(2) and clone(2) would be safe when</div><div class="line">no_new_privs is set, and no_new_privs + chroot is considerable less</div><div class="line">dangerous than chroot by itself.</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在未来，在”no_new_privs”模式下，将出现其他具有威胁内核的功能被非法的任务所应用。原则上，在”no_new_privs”模式下需要对unshare(2),以及clone(2)进行配置设置。实现”no_new_privs”与chroot的组合使用方式是一种相比与独立使用chroot的一种可实现的低风险方案。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;The original article, please reference here &lt;a href=&quot;http://tomoyo.osdn.jp/cgi-bin/lxr/source/Documentation/prctl/no_new_privs.txt&quot; targe
    
    </summary>
    
      <category term="translation" scheme="https://turbin.github.io/categories/translation/"/>
    
    
      <category term="Linux kernel" scheme="https://turbin.github.io/tags/Linux-kernel/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="https://turbin.github.io/2016/09/14/Promise/"/>
    <id>https://turbin.github.io/2016/09/14/Promise/</id>
    <published>2016-09-14T12:30:45.000Z</published>
    <updated>2017-02-05T05:22:50.288Z</updated>
    
    <content type="html"><![CDATA[<p>由于项目开发需要解决JS同步的问题，但是受限在目前的框架里没有引用到jQuery，也就无法使用defered。也是自己嫌麻烦，于是开始重新造轮子的过程——服务于自己的测试代码，写了一个简易的promise的实现。</p>
<p><a href="https://github.com/turbin/JavascriptUtility.git" target="_blank" rel="external">Promise</a>下面有个src/Promise.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by turbineyan on 9/12/16.</div><div class="line"> */</div><div class="line">function Promise()&#123;</div><div class="line">&#125;</div><div class="line">Promise.prototype = &#123;</div><div class="line">    callback:null, caller:null,onDone:null,</div><div class="line">    when:function()&#123;</div><div class="line">        if(this.callbacks)&#123;</div><div class="line">            this.callbacks = null;</div><div class="line">        &#125;</div><div class="line">        this.callbacks = [];</div><div class="line">        this.caller = null;</div><div class="line">        for(var i=0; i!=arguments.length; i++)&#123;</div><div class="line">            this.callbacks.push(&#123;fn:arguments[i], onSuccess:this.onSuccess, onFail:this.fail&#125;);</div><div class="line">        &#125;</div><div class="line">        ///this.callbacks[this.idx].fn.call(this, this);</div><div class="line">        return this;</div><div class="line">    &#125;,</div><div class="line">    resolve:function()&#123;</div><div class="line">        this.next();</div><div class="line">        return this;</div><div class="line">    &#125;,</div><div class="line">    reject:function()&#123;</div><div class="line">        this.caller.onFail(this);</div><div class="line">        return this;</div><div class="line">    &#125;,</div><div class="line">    done:function(callback)&#123;</div><div class="line">        this.onDone = callback;</div><div class="line">        return this;</div><div class="line">    &#125;,</div><div class="line">    onSuccess:function(promise)&#123;</div><div class="line">        console.log(&apos;on success!&apos;);</div><div class="line">    &#125;,</div><div class="line">    next:function()&#123;</div><div class="line">        this.caller = null;</div><div class="line">        if(this.callbacks.length !== 0)&#123;</div><div class="line">            this.caller= this.callbacks.shift(1);</div><div class="line">            this.caller.fn(this);</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line">        if(this.onDone)this.onDone(this);</div><div class="line">        return this;</div><div class="line">    &#125;,</div><div class="line">    fail:function(promise) &#123;</div><div class="line">        var fn =this.caller.fn;</div><div class="line">        this.caller = null;</div><div class="line">        throw new EvalError(&apos;promise call &apos; + fn + &apos; call fail!&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>简单说明下，通过数组来组成一个链的结构。然后通过resovle和reject配合使用，实现类职责链的效果。<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var promise = new Promise();</div><div class="line">promise.when(</div><div class="line">   function(promise)&#123; // step 1</div><div class="line">      // 在这里调用具体的函数实现，</div><div class="line">      // 如果成功，则执行promise.resolve()后，</div><div class="line">      // 执行链上的下一个函数，</div><div class="line">      // 如果失败,则调用promise.reject(),随后fail()会被执行</div><div class="line">      // 如果链上的所有步骤都成功，则最终执行done   </div><div class="line">   &#125;,</div><div class="line">).next()</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于项目开发需要解决JS同步的问题，但是受限在目前的框架里没有引用到jQuery，也就无法使用defered。也是自己嫌麻烦，于是开始重新造轮子的过程——服务于自己的测试代码，写了一个简易的promise的实现。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github
    
    </summary>
    
      <category term="coding" scheme="https://turbin.github.io/categories/coding/"/>
    
    
      <category term="JavaScript" scheme="https://turbin.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Javascript Examples</title>
    <link href="https://turbin.github.io/2016/09/13/Javascript-Examples/"/>
    <id>https://turbin.github.io/2016/09/13/Javascript-Examples/</id>
    <published>2016-09-13T12:46:36.000Z</published>
    <updated>2017-02-05T05:23:06.301Z</updated>
    
    <content type="html"><![CDATA[<p>摘自《Javascript权威教程》</p>
<h3 id="Monkey-Path"><a href="#Monkey-Path" class="headerlink" title="Monkey Path"></a>Monkey Path</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function trace(o, m)&#123;</div><div class="line">   var original = o[m];</div><div class="line">   o[m] = function()&#123;</div><div class="line">        console.log(new Date(), &quot;Entering:&quot;, m);</div><div class="line">        var result = original.apply(this, arguments);</div><div class="line">        console.log(new Date(), &quot;Exiting:&quot;, m);</div><div class="line">        return result;</div><div class="line">   &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这种方法，更像是装饰器——动态添加了函数对象原本不支持的职责，缺不破坏函数本身。</p>
<h3 id="Bind方法"><a href="#Bind方法" class="headerlink" title="Bind方法:"></a>Bind方法:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">if(!Function.prototype.bind) &#123;</div><div class="line">   Function.prototype.bind = function(o /*, args */)&#123;</div><div class="line">      // 将this 和arguments 的值保存至变量中</div><div class="line">      // 以便后面嵌套的函数中可以使用它们</div><div class="line">      var self = this, boundArgs = arguments;</div><div class="line"></div><div class="line">      return function() &#123;</div><div class="line">           var args = [], i;</div><div class="line">           for(i=1; i &lt; boundArgs.length; i++) args.push(boundArgs[i]);</div><div class="line">           for(i=0; i &lt; arguments.length; i++) args.push(arguments[i]);</div><div class="line">           return self.apply(o, args);</div><div class="line">      &#125;;</div><div class="line">   &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是对使用ECMA-Script3 标准对ECMA-Script5标准的扩展。支持动态绑定，就像jQuery中的on方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘自《Javascript权威教程》&lt;/p&gt;
&lt;h3 id=&quot;Monkey-Path&quot;&gt;&lt;a href=&quot;#Monkey-Path&quot; class=&quot;headerlink&quot; title=&quot;Monkey Path&quot;&gt;&lt;/a&gt;Monkey Path&lt;/h3&gt;&lt;figure cla
    
    </summary>
    
      <category term="coding" scheme="https://turbin.github.io/categories/coding/"/>
    
    
      <category term="JavaScript" scheme="https://turbin.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
